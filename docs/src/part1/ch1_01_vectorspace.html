<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; 벡터와 벡터공간 – 대수학</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../src/part1/ch1_02_linear_map.html" rel="next">
<link href="../../src/part1/part1.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/part1/part1.html">I. 선형대수학의 기초 : 벡터공간에서 특이값 분해까지</a></li><li class="breadcrumb-item"><a href="../../src/part1/ch1_01_vectorspace.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">벡터와 벡터공간</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">대수학</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../src/part1/part1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">I. 선형대수학의 기초 : 벡터공간에서 특이값 분해까지</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_01_vectorspace.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">벡터와 벡터공간</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_02_linear_map.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">선형사상</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_03_determinant.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">가우스 조단 소거법과 행렬식</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_04_eigenvalue.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">고유값과 고유벡터</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_05_innerproduct.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">내적</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_06_operators_on_innerproduct_space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">내적벡터공간에서의 연산자</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_07_spectrum_theorem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">스펙트럼 정리</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_08_svd.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">특이값 분해</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../src/part2/part2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">II. 군 (Groups)</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part2/ch2_01_groups.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">군의 기초</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part2/ch2_02_homomorphisms.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">군에서의 준동형사상과 동형사상</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part2/ch2_03_normal_subgroup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">정규부분군과 몫군</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part2/ch2_04_symmetry.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Symmetry</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../src/part3/part3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">III. 심화 선형대수학</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/quotient_space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">몫공간과 몫사상</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/dual_space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">쌍대공간과 쌍대 사상</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/bilinear_form.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">다중선형 형식</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/laplacian_form_of_determinant.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">행렬식의 라플라시안 형식</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/generalized_inverse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">일반화된 역행렬과 유사역행렬</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/characteristic_polynomial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">특성다항식, 최소다항식과 케일리-해밀턴 정리</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/generalized_eigenspace.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">일반화된 고유공간과 조르당 형식</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/tensor_product.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">텐서곱</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#기본적인-개념" id="toc-기본적인-개념" class="nav-link active" data-scroll-target="#기본적인-개념"><span class="header-section-number">1.1</span> 기본적인 개념</a>
  <ul class="collapse">
  <li><a href="#스칼라-scalar" id="toc-스칼라-scalar" class="nav-link" data-scroll-target="#스칼라-scalar"><span class="header-section-number">1.1.1</span> 스칼라 (Scalar)</a></li>
  <li><a href="#행렬-matrix" id="toc-행렬-matrix" class="nav-link" data-scroll-target="#행렬-matrix"><span class="header-section-number">1.1.2</span> 행렬 (Matrix)</a></li>
  <li><a href="#순서집합-ordered-set" id="toc-순서집합-ordered-set" class="nav-link" data-scroll-target="#순서집합-ordered-set"><span class="header-section-number">1.1.3</span> 순서집합 (Ordered set)</a></li>
  <li><a href="#데카르트-곱" id="toc-데카르트-곱" class="nav-link" data-scroll-target="#데카르트-곱"><span class="header-section-number">1.1.4</span> 데카르트 곱</a></li>
  <li><a href="#크로네커-델타-함수" id="toc-크로네커-델타-함수" class="nav-link" data-scroll-target="#크로네커-델타-함수"><span class="header-section-number">1.1.5</span> 크로네커 델타 함수</a></li>
  </ul></li>
  <li><a href="#벡터공간과-벡터" id="toc-벡터공간과-벡터" class="nav-link" data-scroll-target="#벡터공간과-벡터"><span class="header-section-number">1.2</span> 벡터공간과 벡터</a>
  <ul class="collapse">
  <li><a href="#벡터공간" id="toc-벡터공간" class="nav-link" data-scroll-target="#벡터공간"><span class="header-section-number">1.2.1</span> 벡터공간</a></li>
  <li><a href="#중요한-벡터공간들" id="toc-중요한-벡터공간들" class="nav-link" data-scroll-target="#중요한-벡터공간들"><span class="header-section-number">1.2.2</span> 중요한 벡터공간들</a></li>
  </ul></li>
  <li><a href="#부분공간과-직합" id="toc-부분공간과-직합" class="nav-link" data-scroll-target="#부분공간과-직합"><span class="header-section-number">1.3</span> 부분공간과 직합</a>
  <ul class="collapse">
  <li><a href="#부분공간" id="toc-부분공간" class="nav-link" data-scroll-target="#부분공간"><span class="header-section-number">1.3.1</span> 부분공간</a></li>
  <li><a href="#sec-direct_sum" id="toc-sec-direct_sum" class="nav-link" data-scroll-target="#sec-direct_sum"><span class="header-section-number">1.3.2</span> 합공간과 직합</a></li>
  </ul></li>
  <li><a href="#벡터공간의-기저와-차원" id="toc-벡터공간의-기저와-차원" class="nav-link" data-scroll-target="#벡터공간의-기저와-차원"><span class="header-section-number">1.4</span> 벡터공간의 기저와 차원</a>
  <ul class="collapse">
  <li><a href="#sec-linear_combinatin_and_span" id="toc-sec-linear_combinatin_and_span" class="nav-link" data-scroll-target="#sec-linear_combinatin_and_span"><span class="header-section-number">1.4.1</span> 선형결합과 Span</a></li>
  <li><a href="#유한차원-벡터공간과-무한차원-벡터공간-선형독립과-선형종속" id="toc-유한차원-벡터공간과-무한차원-벡터공간-선형독립과-선형종속" class="nav-link" data-scroll-target="#유한차원-벡터공간과-무한차원-벡터공간-선형독립과-선형종속"><span class="header-section-number">1.4.2</span> 유한차원 벡터공간과 무한차원 벡터공간, 선형독립과 선형종속</a></li>
  <li><a href="#벡터공간의-기저-와-순서-기저" id="toc-벡터공간의-기저-와-순서-기저" class="nav-link" data-scroll-target="#벡터공간의-기저-와-순서-기저"><span class="header-section-number">1.4.3</span> 벡터공간의 기저 와 순서 기저</a></li>
  <li><a href="#span-하는-벡터로부터-기저를-추출하기" id="toc-span-하는-벡터로부터-기저를-추출하기" class="nav-link" data-scroll-target="#span-하는-벡터로부터-기저를-추출하기"><span class="header-section-number">1.4.4</span> Span 하는 벡터로부터 기저를 추출하기</a></li>
  <li><a href="#유한차원-벡터공간의-차원" id="toc-유한차원-벡터공간의-차원" class="nav-link" data-scroll-target="#유한차원-벡터공간의-차원"><span class="header-section-number">1.4.5</span> 유한차원 벡터공간의 차원</a></li>
  <li><a href="#합공간의-차원" id="toc-합공간의-차원" class="nav-link" data-scroll-target="#합공간의-차원"><span class="header-section-number">1.4.6</span> 합공간의 차원</a></li>
  </ul></li>
  <li><a href="#벡터의-행렬표현" id="toc-벡터의-행렬표현" class="nav-link" data-scroll-target="#벡터의-행렬표현"><span class="header-section-number">1.5</span> 벡터의 행렬표현</a>
  <ul class="collapse">
  <li><a href="#벡터의-행렬표현-1" id="toc-벡터의-행렬표현-1" class="nav-link" data-scroll-target="#벡터의-행렬표현-1"><span class="header-section-number">1.5.1</span> 벡터의 행렬표현</a></li>
  <li><a href="#열벡터와-표준-기저" id="toc-열벡터와-표준-기저" class="nav-link" data-scroll-target="#열벡터와-표준-기저"><span class="header-section-number">1.5.2</span> 열벡터와 표준 기저</a></li>
  </ul></li>
  <li><a href="#연습문제" id="toc-연습문제" class="nav-link" data-scroll-target="#연습문제">연습문제</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/part1/part1.html">I. 선형대수학의 기초 : 벡터공간에서 특이값 분해까지</a></li><li class="breadcrumb-item"><a href="../../src/part1/ch1_01_vectorspace.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">벡터와 벡터공간</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">벡터와 벡터공간</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="hidden">
<p>% %</p>
%
<p><span class="math display">\[
\DeclarePairedDelimiters{\set}{\{}{\}}
\DeclareMathOperator*{\argmax}{argmax}
\]</span></p>
</div>
<p><br></p>
<section id="기본적인-개념" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="기본적인-개념"><span class="header-section-number">1.1</span> 기본적인 개념</h2>
<section id="스칼라-scalar" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="스칼라-scalar"><span class="header-section-number">1.1.1</span> 스칼라 (Scalar)</h3>
<p>실수의 집합 <span class="math inline">\(\mathbb{R}\)</span> 이나 복소수의 집합 <span class="math inline">\(\mathbb{C}\)</span> 는 수학적으로 체(field) 라고 불리는 사칙연산이 잘 정의된 집합이다. <span class="math inline">\(\mathbb{R},\,\mathbb{C}\)</span> 이외에도 체가 존재하지만 여기서는 이 둘만 다루기로 한다. 체의 원소를 <strong>스칼라(scalar)</strong> 라 한다. <span class="math inline">\(\mathbb{F}\)</span> 는 <span class="math inline">\(\mathbb{R}\)</span> 과 <span class="math inline">\(\mathbb{C}\)</span> 를 같이 생각하는 경우 사용한다.</p>
<p>복소수의 경우 <span class="math inline">\(x,\, y\in \mathbb{R}\)</span> 일 때 <span class="math inline">\(z=x+yi\)</span> 로 표현 할 수 있다. 이 때 <span class="math inline">\(x\)</span> 를 복소수 <span class="math inline">\(z\)</span> 의 실수부, <span class="math inline">\(y\)</span> 를 허수부라고 하며 <span class="math inline">\(\text{Re}(z)=x\)</span>, <span class="math inline">\(\text{Im}(z)=y\)</span> 이다. <span class="math inline">\(z=x+iy,\, x,\,y\in \mathbb{R}\)</span> 에 대해 <span class="math inline">\(z\)</span> 의 켤레복소수 <span class="math inline">\(\overline{z}\)</span> 는 <span class="math inline">\(\overline{z}=x-iy\)</span> 로 정의된다.</p>
<p><br></p>
</section>
<section id="행렬-matrix" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="행렬-matrix"><span class="header-section-number">1.1.2</span> 행렬 (Matrix)</h3>
<p>수(Number), 기호, 수식 등의 수학적 대상을 2차원 격자에 배치한 것을 <strong>행렬(matrix)</strong> 이라고 한다. <span class="math inline">\(m\times n\)</span> 행렬은 세로로 <span class="math inline">\(m\)</span> 칸, 가로로 <span class="math inline">\(n\)</span> 칸의 격자에 배치한 행렬이다. 예를 들어,</p>
<p><span class="math display">\[
\boldsymbol{A} = \begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6\end{bmatrix}
\]</span></p>
<p>은 <span class="math inline">\(2 \times 3\)</span> 행렬이다. 행렬에서 가로로 된 한 줄을 행이라 하고, 세로로 된 한 줄을 열이라 한다. 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 에서 <span class="math inline">\(\begin{bmatrix} 1 &amp; 2 &amp; 3\end{bmatrix}\)</span> 는 행이고, <span class="math inline">\(\begin{bmatrix} 1 \\ 4 \end{bmatrix}\)</span> 는 열이다. 행렬을 이루는 각각의 수학적 대상을 <strong>원소(element)</strong> 혹은 <strong>성분(entry)</strong> 이라 한다. 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 는 <span class="math inline">\(1\)</span>, <span class="math inline">\(2\)</span>, <span class="math inline">\(3\)</span>, <span class="math inline">\(4\)</span>, <span class="math inline">\(5\)</span>, <span class="math inline">\(6\)</span> 의 <span class="math inline">\(6\)</span> 개의 성분을 가지며, 보통 <span class="math inline">\(m\times n\)</span> 행렬은 <span class="math inline">\(mn\)</span> 개의 성분을 가진다.</p>
<p><span class="math inline">\((\boldsymbol{A})_{ij}\)</span> 혹은 기울어진 일반글씨체의 <span class="math inline">\(A_{ij}\)</span> 는 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 <span class="math inline">\(i\)</span> 번째 행, <span class="math inline">\(j\)</span> 번째 열을 지칭한다. 행은 위부터 <span class="math inline">\(1,\,2,\ldots\)</span> 순서로 세며, 열은 왼쪽부터 <span class="math inline">\(1,\,2,\ldots\)</span> 의 순서로 센다. 즉 <span class="math inline">\(A_{11}=1\)</span> 이며 <span class="math inline">\(A_{23}=6\)</span> 이다.</p>
<div class="callout callout-style-simple callout-warning no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>여기서 행렬을 표기할때는 <span class="math inline">\(\boldsymbol{A}\)</span> 와 같은 기울어진 굵은 글씨체 대문자를 쓰지만, 행렬의 성분을 표기할때는 편의에 따라 <span class="math inline">\((\boldsymbol{A})_{ij},\, \boldsymbol{A}_{ij}\)</span> 나, 혼동의 여지가 없다고 판단될 경우 <span class="math inline">\(A_{ij}\)</span> 와 같이 일반글씨체 대문자를 사용하도록 하겠다.</p>
</div>
</div>
</div>
<p>실수 성분을 갖는 <span class="math inline">\(m \times n\)</span> 행렬 전체의 집합을 <span class="math inline">\(\mathcal{M}_{m \times n}(\mathbb{R})\)</span> 으로 표기한다. 마찬가지로 복소수 성분을 갖는 <span class="math inline">\(m \times n\)</span> 행렬 전체의 집합을 <span class="math inline">\(\mathcal{M}_{m \times n}(\mathbb{C})\)</span> 으로 표기하도록 한다.</p>
<p><br></p>
</section>
<section id="순서집합-ordered-set" class="level3" data-number="1.1.3">
<h3 data-number="1.1.3" class="anchored" data-anchor-id="순서집합-ordered-set"><span class="header-section-number">1.1.3</span> 순서집합 (Ordered set)</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-ordered_set" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.1 (순서집합)</strong></span> 일반적으로 <span class="math inline">\(\{y_1,\,y_2,\ldots\}\)</span> 처럼 기술되는 집합은 집합 내의 원소를 나열하는 순서가 중요하지 않다. 하지만 그 순서가 중요한 경우가 있는데 이 경우 집합에 순서를 부여하여 <span class="math inline">\((x_1,\,x_2,\,x_3,\ldots)\)</span> 와 같이 <span class="math inline">\((\quad)\)</span> 안에 나열하여 표현한다. 즉, <span class="math inline">\(\{a,\,b\} = \{b,\,a\}\)</span> 이지만 <span class="math inline">\((a,\,b) \ne (b,\,a)\)</span> 이다. 순서집합의 대표적인 경우가 수열이다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="데카르트-곱" class="level3" data-number="1.1.4">
<h3 data-number="1.1.4" class="anchored" data-anchor-id="데카르트-곱"><span class="header-section-number">1.1.4</span> 데카르트 곱</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-cartesian_product" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.2 (데카르트곱)</strong></span> 집합 <span class="math inline">\(A\)</span> 와 <span class="math inline">\(B\)</span> 에 대해 <span class="math inline">\(A\)</span> 와 <span class="math inline">\(B\)</span> 의 원소로 이루어진 새로운 집합 <span class="math inline">\(A\times B\)</span> 를 다음과 같이 정의하자.</p>
<p><span class="math display">\[
A \times B = \{(a,\,b) : a\in A,\, b \in B\}
\]</span></p>
<p>이렇게 정의된 집합을 데카르트 곱이라 한다. <span class="math inline">\(\mathbb{R}\times \mathbb{R} \times \mathbb{R}\)</span> 을 생각해보자,</p>
<p><span class="math display">\[
\mathbb{R}\times \mathbb{R} \times \mathbb{R} = \{ (x_1,\,x_2,\,x_3) : x_1\in\mathbb{R},\, x_2\in\mathbb{R},\, x_3\in \mathbb{R}\}
\]</span></p>
<p>이다. 이것을 간략히 하여 <span class="math inline">\(\mathbb{R}^3\)</span> 로 표현 할 수 있다. 우리는 이로부터 <span class="math inline">\(\mathbb{C}^4\)</span> 가 어떤 것을 의미하는지 알 수 있을 것이다.</p>
<p>집합 <span class="math inline">\(V_1,\ldots,\,V_m\)</span> 에 대해 <span class="math inline">\(V=V_1 \times \cdots \times V_m\)</span> 이라 하자. <span class="math inline">\(v\in V\)</span> 라면 <span class="math inline">\(v=(v_1,\ldots,\,v_m)\)</span> 이며 <span class="math inline">\(v_i \in V_i\)</span> 이다. 이 때 <span class="math inline">\(v_i\)</span> 를 <span class="math inline">\(v\)</span> 의 <span class="math inline">\(i\)</span> 번째 <strong>성분</strong>, 혹은 <span class="math inline">\(i\)</span> 번째 <strong>좌표</strong>라고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-warning no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>보통 <span class="math inline">\(\mathbb{R}^3\)</span> 는 실수의 데카르트곱에 유클리드 거리를 부여한 3차원 실수 공간을 의미하기도 한다.</p>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="크로네커-델타-함수" class="level3" data-number="1.1.5">
<h3 data-number="1.1.5" class="anchored" data-anchor-id="크로네커-델타-함수"><span class="header-section-number">1.1.5</span> 크로네커 델타 함수</h3>
<p>앞으로 많이 사용될 간단하지만 유용한 함수가 있다.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-kroneker_delter" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.3 (크로네커 델타 함수)</strong></span> <span class="math inline">\(i,\,j\)</span> 가 정수일 때 다음과 같이 정의된 함수 <span class="math inline">\(\delta_{ij}\)</span> 를 크로네커 델타 함수 (Kronecker delta function)라고 한다.</p>
<p><span class="math display">\[
\delta_{ij} = \left\{\begin{array}{ll} 1 \qquad &amp;\text{if } i = j, \\ 0 &amp;\text{otherwise}. \end{array}\right.
\]</span></p>
</div>
</div>
</div>
</div>
<p><br></p>
</section>
</section>
<section id="벡터공간과-벡터" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="벡터공간과-벡터"><span class="header-section-number">1.2</span> 벡터공간과 벡터</h2>
<section id="벡터공간" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="벡터공간"><span class="header-section-number">1.2.1</span> 벡터공간</h3>
<p>벡터공간을 정의하기 위해서는 어떤 집합 <span class="math inline">\(V\)</span> 와 체(field) <span class="math inline">\(\mathbb{F}\)</span>, 그리고 <span class="math inline">\(V\)</span> 의 원소끼리의 덧셈과, <span class="math inline">\(V\)</span> 의 원소와 <span class="math inline">\(\mathbb{F}\)</span> 의 원소의 곱이 정의되어야 한다. 이 때, 집합 <span class="math inline">\(V\)</span> 과 체 <span class="math inline">\(\mathbb{F}\)</span> 에 대해 아래의 성질을 만족하면 집합 <span class="math inline">\(V\)</span> 를 <span class="math inline">\(\mathbb{F}\)</span> 위에서의 <strong>벡터공간(vector space)</strong> 혹은 <strong><span class="math inline">\(\mathbb{F}\)</span>-벡터공간</strong> 이라 한다.</p>
<ol type="1">
<li><p><span class="math inline">\(V\)</span> 의 원소 <span class="math inline">\(v\)</span> 와 <span class="math inline">\(\mathbb{F}\)</span> 의 원소 <span class="math inline">\(a\)</span> 의 곱은 <span class="math inline">\(av\)</span> 라 쓰며 <span class="math inline">\(V\)</span> 에 포함된다.</p></li>
<li><p><span class="math inline">\(V\)</span> 는 덧셈에 대해 닫혀 있다.</p></li>
<li><p><span class="math inline">\(V\)</span> 의 두 원소 사이의 덧셈에 대한 교환법칙이 성립한다. 즉 <span class="math inline">\(u,\,v\in V\)</span> 일 때 <span class="math inline">\(u + v = v + u\)</span> 이다.</p></li>
<li><p><span class="math inline">\(V\)</span> 의 원소사이의 덧셈에 대해 결합법칙이 성립한다. 즉 <span class="math inline">\(u,\,v,\,w \in V\)</span> 일 때 <span class="math inline">\((u+v)+w = u+(v+w)\)</span> 이다.</p></li>
<li><p><span class="math inline">\(V\)</span> 의 원소와 두 두 스칼라 사이에 곱셈에 대한 결합법칙이 성립한다. 즉 <span class="math inline">\(v\in V\)</span> 이고 <span class="math inline">\(a,\,b\in V\)</span> 일 때 <span class="math inline">\(a(bv)=(ab)v\)</span> 이다.</p></li>
<li><p>어떤 <span class="math inline">\(0_V \in V\)</span> 가 존재하여 모든 <span class="math inline">\(v\in V\)</span> 에 대해 <span class="math inline">\(v+0_V = 0_V +v= v\)</span> 이다.</p></li>
<li><p>각각의 <span class="math inline">\(v\in V\)</span> 에 대해 <span class="math inline">\(v+w=w+v=0_V\)</span> 을 만족하는 <span class="math inline">\(w\in V\)</span> 가 존재한다. 이 때 <span class="math inline">\(v\)</span> 의 덧셈에 대한 역원을 <span class="math inline">\(-v\)</span> 라고 쓴다.</p></li>
<li><p>체의 곱셈에 대한 항등원 <span class="math inline">\(1_\mathbb{F}\)</span> 에 대해 <span class="math inline">\(v\in V\)</span> 이면 <span class="math inline">\(1_\mathbb{F} v = v\)</span> 이다.</p></li>
<li><p>다음과 같은 분배법칙을 만족한다.</p></li>
</ol>
<p><span class="math display">\[
u,\,v \in V,\, a,\, b\in \mathbb{F} \implies a(u+v)=au + av,\, (a+b)v = av+bv
\]</span></p>
<p>이 조건을 만족하는 벡터공간 <span class="math inline">\(V\)</span> 의 원소를 <strong>벡터 (vector)</strong> 라 한다. 6. 에 나오는 벡터공간 <span class="math inline">\(V\)</span> 에서 덧셈에 대한 항등원인 벡터를 영벡터라 하고 <span class="math inline">\(0_V\)</span> 라 쓴다. 혼돈의 여지가 없을 경우는 단순히 <span class="math inline">\(0\)</span> 으로만 쓸 수 도 있다.</p>
<p>이것을 수학적으로 다시 정리하면 다음과 같다.</p>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-vector_space_2" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.4 (벡터공간과 벡터)</strong></span> 어떤 집합 <span class="math inline">\(V\)</span> 와 체 <span class="math inline">\(\mathbb{F}\)</span> 에 대해 <span class="math inline">\(V\)</span> 의 원소 사이의 덧셈과 <span class="math inline">\(\mathbb{F}\)</span> 와 <span class="math inline">\(V\)</span> 사이의 곱셈이 정의되어 있으며, 다음이 성립하면 <span class="math inline">\(V\)</span> 를 <strong><span class="math inline">\(\mathbb{F}\)</span> 위에서의 벡터공간</strong> 혹은 <strong><span class="math inline">\(\mathbb{F}\)</span>-벡터공간</strong> 이라 한다.</p>
<p> (<span class="math inline">\(1\)</span>) <span class="math inline">\(u,\,v \in V ,\, a\in \mathbb{F} \implies u+v = v+u \in V\)</span>, <span class="math inline">\(av\in V\)</span>,</p>
<p> (<span class="math inline">\(2\)</span>) <span class="math inline">\(u,\,v,\,w \in V,\, a,\, b\in \mathbb{F} \implies (u + v) + w = u+(v+w)\)</span>, <span class="math inline">\((ab)v = a(bv)\)</span>,</p>
<p> (<span class="math inline">\(3\)</span>) <span class="math inline">\(\exists 0_V\in V\, \forall v\in V,\, v + 0_V=0_V+v = v\)</span>,</p>
<p> (<span class="math inline">\(4\)</span>) <span class="math inline">\(\forall v\in V \;\exists w\in V\)</span> s.t. <span class="math inline">\(v + w = 0_V\)</span>,</p>
<p> (<span class="math inline">\(5\)</span>) <span class="math inline">\(\forall v \in V \implies 1v =v\)</span>,</p>
<p> (<span class="math inline">\(6\)</span>) <span class="math inline">\(u,\,v \in V,\, a,\, b\in \mathbb{F} \implies a(u+v)=au + av,\, (a+b)v = av+bv\)</span>.</p>
<p>벡터공간 <span class="math inline">\(V\)</span> 가 정의되었을 때 벡터공간의 원소를 <strong>벡터(vector)</strong> 라 한다. <span class="math inline">\(\mathbb{R}\)</span> 위에서의 벡터 공간을 <strong>실벡터공간(real vector space)</strong> 혹은 <strong><span class="math inline">\(\mathbb{R}\)</span>-벡터공간</strong>, <span class="math inline">\(\mathbb{C}\)</span> 위에서의 벡터 공간을 <strong>복소벡터공간(complex vector space)</strong> 혹은 <strong><span class="math inline">\(\mathbb{C}\)</span>-벡터공간</strong> 이라 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-warning no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>앞으로 <span class="math inline">\(u,\,v,\,w\)</span> 세 문자는 벡터를 나타내는 문자로 고정하며, 다른 볼드체가 아닌 수학적 문자는 특별한 언급이 없을 경우 스칼라를 의미한다. <span class="math inline">\(0\)</span> 은 문맥에 따라 스칼라 <span class="math inline">\(0\)</span> 을 의미할 수도 있고, <span class="math inline">\(0\)</span> 벡터를 의미할 수도 있다.</p>
</div>
</div>
</div>
<p><br></p>
<p>앞으로 <span class="math inline">\(\mathbb{F}\)</span>-벡터공간이라는 용어가 많이 등장할 것이다. 이 경우 하나의 명제나 문제 안에서 <span class="math inline">\(\mathbb{F}\)</span> 는 <span class="math inline">\(\mathbb{R}\)</span> 혹은 <span class="math inline">\(\mathbb{C}\)</span> 로 고정된다. 예를 들어 <span class="math inline">\(\mathbb{F}\)</span>-벡터공간인 <span class="math inline">\(U,\,V\)</span> 라고 했다면 <span class="math inline">\(U, V\)</span> 는 둘 다 <span class="math inline">\(\mathbb{R}\)</span>-벡터공간이거나, 둘 다 <span class="math inline">\(\mathbb{C}\)</span>-벡터공간이라고 간주되어야 하며, 둘중 하나는 <span class="math inline">\(\mathbb{R}\)</span>-벡터공간, 다른 하나는 <span class="math inline">\(\mathbb{C}\)</span>-벡터공간이어서는 안된다.</p>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-zero_one_vector" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.1</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 와 <span class="math inline">\(v\in V\)</span> 그리고 영벡터 <span class="math inline">\(O_V\)</span> 에 대해 다음이 성립한다.</p>
<p> (<span class="math inline">\(1\)</span>) 영벡터는 유일하다.</p>
<p> (<span class="math inline">\(2\)</span>) <span class="math inline">\(0v = 0_V\)</span></p>
<p> (<span class="math inline">\(3\)</span>) <span class="math inline">\((-1)v = -v\)</span></p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(1\)</span>) 두 영벡터를 각각 <span class="math inline">\(0_V\)</span> 와 <span class="math inline">\(0'_V\)</span> 라고 하자. <span class="math inline">\(0_V = 0_V+0'_V = 0'_V\)</span>.</p>
<p>(<span class="math inline">\(2\)</span>) <span class="math inline">\(0v = (0+0)v = 0v + 0v\)</span> 이므로 <span class="math inline">\(0v = 0_V\)</span> 이다.</p>
<p>(<span class="math inline">\(3\)</span>) <span class="math inline">\(0_V = 0v =  (1-1)v = v + (-v)\)</span>. 이므로 <span class="math inline">\(v\)</span> 의 덧셈에 대한 역원인 <span class="math inline">\(-v\)</span> 는 <span class="math inline">\((-1)v\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
<section id="중요한-벡터공간들" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="중요한-벡터공간들"><span class="header-section-number">1.2.2</span> 중요한 벡터공간들</h3>
<p>아래의 보기는 앞으로 자주 등장할 벡터공간이다.</p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-vectorspace_F" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.1</strong></span> <span class="math inline">\(\mathbb{F}\)</span> 는 <span class="math inline">\(\mathbb{F}\)</span>-벡터공간이다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-vectorspace_Rn" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.2</strong></span> 데카르트 곱 <span class="math inline">\(\mathbb{R}^2 = \{ (x,\,y): x\in \mathbb{R},\, y\in \mathbb{R}\}\)</span> 을 생각하자. 덧셈과 스칼라곱을 <span class="math inline">\((x_1,\, y_1) + (x_2,\,y_2) = (x_1+x_2,\, y_1+y_2)\)</span>, <span class="math inline">\(a(x,\, y) = (ax,\, ay)\)</span> 로 정의하면 <span class="math inline">\(\mathbb{R}^2\)</span> 가 <span class="math inline">\(\mathbb{R}\)</span> 위의 벡터공간임을 쉽게 알 수 있다. 이로부터 임의의 0이 아닌 자연수 <span class="math inline">\(n\)</span> 에 대해 <span class="math inline">\(\mathbb{R}^n\)</span> 이 <span class="math inline">\(\mathbb{R}\)</span>-벡터공간이고, <span class="math inline">\(\mathbb{C}^n\)</span> 이 <span class="math inline">\(\mathbb{C}\)</span>-벡터공간임을 알 수 있다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-vectorspace_CnRn" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.3</strong></span> 합과 스칼라곱이 아래와 같이 정의된 데카르트곱 <span class="math inline">\(\mathbb{R}^n\)</span> 과 <span class="math inline">\(\mathbb{C}^n\)</span> 을 생각하자.</p>
<p><span class="math display">\[
(x_1,\ldots,\,x_n) + a(y_1,\ldots,\,y_n) = (x_1 + ay_n, \ldots,\, x_n+ay_n)
\]</span></p>
<p>이 때 <span class="math inline">\(\mathbb{C}^n\)</span> 은 <span class="math inline">\(\mathbb{R}\)</span>-벡터공간이다. 그러나 <span class="math inline">\(\mathbb{R}^n\)</span> 은 <span class="math inline">\(\mathbb{C}\)</span>-벡터공간이 될 수 없다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-vectorspace_polynomial" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.4</strong></span> 다항식 <span class="math inline">\(p(x) = a_0 + a_1 x + \cdots + a_n x^n\)</span> 을 생각하자. <span class="math inline">\(a_n\ne 0\)</span> 일 때 <span class="math inline">\(p(x)\)</span> 를 <span class="math inline">\(n\)</span> 차 다항식이라고 하며 이때의 <span class="math inline">\(n\)</span> 값을 다항식 <span class="math inline">\(p(x)\)</span> 의 <strong>차수 (degree)</strong> 라고 하고 <span class="math inline">\(\deg (p)\)</span> 혹은 <span class="math inline">\(\deg (p(x))\)</span> 라고 표기한다. 굳이 0차 다항식이라고 이름을 붙이지는 않지만 상수함수도 다항식에 포함된다. 앞으로 <span class="math inline">\(\mathbb{F}\)</span> 값을 계수로 갖는 변수 <span class="math inline">\(t\)</span> 에 대한 다항식의 집합을 <span class="math inline">\(\mathbb{F}[t]\)</span> 라고 표기하며, <span class="math inline">\(\mathbb{F}_n[t]\)</span> 는 <span class="math inline">\(n\)</span> 차를 포함하여 그 이하의 차수를 갖는 다항식의 집합을 의미한다. 예를 들어 <span class="math inline">\(\mathbb{R}_3[t]\)</span> 는 3차 이하의 차수를 갖는 실계수 다항식의 집합을 말한다. 0 이상의 정수 <span class="math inline">\(n\)</span> 에 대해 <span class="math inline">\(\mathbb{F}_n[t]\)</span> 은 <span class="math inline">\(\mathbb{F}\)</span>-벡터공간이다. 또한 <span class="math inline">\(\mathbb{F}[t]\)</span> 도 벡터공간이다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-vectorspace_matrix" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.5</strong></span> 실계수를 갖는 <span class="math inline">\(m \times n\)</span> 행렬의 집합을 <span class="math inline">\(\mathcal{M}_{m \times n}(\mathbb{R})\)</span> 이이라고 하기로 하였다. <span class="math inline">\(\boldsymbol{A},\,\boldsymbol{B}\in \mathcal{M}_{m \times n}(\mathbb{R})\)</span> 일 때 두 행렬을 더하면 그 결과는 같은 크기의 행렬이며 더하여 나온 행렬의 성분은 같은 위치에서의 <span class="math inline">\(\boldsymbol{A}\)</span> 와 <span class="math inline">\(\boldsymbol{B}\)</span> 의 성분의 합으로 정의하자. 즉,</p>
<p><span class="math display">\[
(\boldsymbol{A}+\boldsymbol{B})_{ij} = (\boldsymbol{A})_{ij} + (\boldsymbol{B})_{ij}
\]</span> 이라 정의한다. 스칼라와 행렬의 곱셈은 행렬의 각 성분의 스칼라곱으로 정의하자. 즉,</p>
<p><span class="math display">\[
(a\boldsymbol{A})_{ij} = a(\boldsymbol{A})_{ij}
\]</span></p>
<p>이라 정의하자. 그렇다면 <span class="math inline">\(\mathcal{M}_{m \times n}(\mathbb{R})\)</span> 은 <span class="math inline">\(\mathbb{R}\)</span>-벡터공간이다. <span class="math inline">\(\mathcal{M}_{m \times n}(\mathbb{C})\)</span> 이 <span class="math inline">\(\mathbb{C}\)</span>-벡터공간임은 쉽게 보일 수 있다. 즉 체 <span class="math inline">\(\mathbb{F}\)</span> 를 원소로 갖는 <span class="math inline">\(m\times n\)</span> 행렬의 집합을 <span class="math inline">\(\mathcal{M}_{m \times n}(\mathbb{F})\)</span> 이라 하면 <span class="math inline">\(\mathcal{M}_{m \times n}(\mathbb{F})\)</span> 은 <span class="math inline">\(\mathbb{F}\)</span>-벡터공간이다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-vectorspace_row_column" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.6 (행벡터와 열벡터)</strong></span> <a href="#exm-vectorspace_matrix" class="quarto-xref">보기&nbsp;<span>1.5</span></a> 에서 <span class="math inline">\(\mathcal{M}_{m\times n}(\mathbb{F})\)</span> 은 벡터공간임을 보였다. 이중에서 특히 <span class="math inline">\(\mathcal{M}_{n \times 1}(\mathbb{F})\)</span> 의 원소를 <strong>열벡터</strong>라고 한다. 특별히 열벡터공간은 <span class="math inline">\(\mathcal{M}_{n}(\mathbb{F})\)</span> 라고 쓰기로 하자. <span class="math inline">\(\mathcal{M}_{1 \times n}(\mathbb{F})\)</span> 의 원소를 <strong>행벡터</strong> 라고 한다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-continuous_function" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.7</strong></span> <span class="math inline">\(C_{(a,\,b)}\)</span> 를 <span class="math inline">\((a,\,b)\)</span> 구간에서 연속인 실함수의 집합이라고 하자. 이 때 <span class="math inline">\(C_{(a,\,b)}\)</span> 는 <span class="math inline">\(\mathbb{R}\)</span>-벡터공간이다. 실수 영역 전체에서 연속인 함수의 집합 <span class="math inline">\(C_{\mathbb{R}}\)</span> 역시 <span class="math inline">\(\mathbb{R}\)</span>-벡터공간이다.</p>
</div>
</div>
<p><br></p>
</section>
</section>
<section id="부분공간과-직합" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="부분공간과-직합"><span class="header-section-number">1.3</span> 부분공간과 직합</h2>
<section id="부분공간" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1" class="anchored" data-anchor-id="부분공간"><span class="header-section-number">1.3.1</span> 부분공간</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-subspace" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.5 (부분공간)</strong></span> <span class="math inline">\(V\)</span> 가 <span class="math inline">\(\mathbb{F}\)</span>-벡터공간이라 하자. <span class="math inline">\(U\)</span> 가 <span class="math inline">\(V\)</span> 의 부분분집합이며, <span class="math inline">\(\mathbb{F}\)</span>-벡터공간일 때 <span class="math inline">\(U\)</span> 를 <span class="math inline">\(V\)</span> 의 <strong>부분공간 (subspace)</strong> 혹은 <strong>부분벡터공간</strong> 이라 한다.</p>
</div>
</div>
</div>
</div>
<p><span class="math inline">\(U\)</span> 가 <span class="math inline">\(V\)</span> 의 부분공간 일 때 <span class="math inline">\(U\le V\)</span> 라 표기하겠다.</p>
<br>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-subspace_0" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.8</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 는 자기 자신의 부분공간이다. <span class="math inline">\(V\)</span> 가 벡터공간일 때 <span class="math inline">\(\{0_V\}\)</span> 도 <span class="math inline">\(V\)</span> 의 부분공간이다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-intersection_of_two_spaces" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.9</strong></span> <span class="math inline">\(U,\,V\)</span> 가 벡터공간일 때 <span class="math inline">\(U \cap V\)</span> 도 벡터공간이다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-subspace_1" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.10</strong></span> 앞서 언급한 벡터공간 <span class="math inline">\(\mathbb{R}^2\)</span> 에 대해 <span class="math inline">\(A= \{ (x,\,0) : x\in \mathbb{R} \}\)</span> 은 <span class="math inline">\(\mathbb{R}^2\)</span> 의 부분집합이며 벡터공간이므로 부분벡터공간이다. <span class="math inline">\(B=\{(x,\, x) : x\in \mathbb{R}\}\)</span> 역시 <span class="math inline">\(\mathbb{R}^2\)</span> 의 부분벡터공간임은 쉽게 알 수 있다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-subspace_2" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.11</strong></span> <a href="#exm-vectorspace_polynomial" class="quarto-xref">보기&nbsp;<span>1.4</span></a> 에서 정의한 <span class="math inline">\(\mathbb{R}_n[t]\)</span> 을 생각하자. <span class="math inline">\(m \le n\)</span> 일 때, <span class="math inline">\(\mathbb{R}_m[t]\)</span> 는 <span class="math inline">\(\mathbb{R}_n[t]\)</span> 의 부분공간이다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-subspace_2" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.12</strong></span> <span class="math inline">\(\mathbb{C}^2\)</span> 는 <span class="math inline">\(\mathbb{C}\)</span>-벡터공간이다. <span class="math inline">\(\mathbb{R}^2\)</span> 는 <span class="math inline">\(\mathbb{C}^2\)</span> 의 부분집합이지만 <span class="math inline">\(\mathbb{C}\)</span>-벡터공간이 아니므로 (<span class="math inline">\(i(1,\,1) = (i,\, ,i) \not\in \mathbb{R}^2\)</span>) <span class="math inline">\(\mathbb{C}^2\)</span> 의 부분공간이 아니다. 그러나, <span class="math inline">\(\mathbb{C}^2\)</span> 는 <span class="math inline">\(\mathbb{R}\)</span>-벡터공간이기도 하다. 그렇다면 <span class="math inline">\(\mathbb{R}^2\)</span> 는 <span class="math inline">\(\mathbb{R}\)</span>- 벡터공간 <span class="math inline">\(\mathbb{C}^2\)</span> 의 부분공간이 된다.</p>
<p>요컨데, <span class="math inline">\(\mathbb{C}\)</span> 위에서의 <span class="math inline">\(\mathbb{C}^2\)</span> 와 <span class="math inline">\(\mathbb{R}\)</span> 위에서의 <span class="math inline">\(\mathbb{C}^2\)</span> 는 다른 벡터공간이며, 부분집합이 부분공간인지 아닌지를 따질 때에 어떤 체(field) 위에서의 벡터공간인지가 중요하다. 엄밀하게 말하면 체 <span class="math inline">\(\mathbb{F}\)</span> 위에서의 벡터공간 <span class="math inline">\(V\)</span> 에서 벡터합 <span class="math inline">\(+\)</span> 와 벡터의 스칼라곱 <span class="math inline">\(\cdot\)</span> 이 정의되었을 때 <span class="math inline">\((V,\,\mathbb{F},\, +,\, \cdot)\)</span> 과 같이 써야한다. 여기서는 이렇게 까지는 하지 않겠다.</p>
</div>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-warning no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>명제, 정리, 보조정리, 따름정리 등에 대한 증명이 아주 쉬운 경우는 언급도 없이 증명을 생략 할 수 있다.</p>
</div>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-subspace_1" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.2</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 에 대해 <span class="math inline">\(U\le V\)</span> 이고 <span class="math inline">\(W \le U\)</span> 이면 <span class="math inline">\(W \le V\)</span> 이다.</p>
</div>
</div>
<p><br></p>
</section>
<section id="sec-direct_sum" class="level3" data-number="1.3.2">
<h3 data-number="1.3.2" class="anchored" data-anchor-id="sec-direct_sum"><span class="header-section-number">1.3.2</span> 합공간과 직합</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-sum_of_subspace" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.6 (합공간)</strong></span> <span class="math inline">\(V_1,\,V_2,\ldots,\,V_m\)</span> 이 모두 <span class="math inline">\(V\)</span> 의 부분공간 일 때 <span class="math inline">\(V_1+\cdots + V_m\)</span> 을 다음과 같이 정의하며 <span class="math inline">\(V_1,\ldots,\,V_m\)</span> 에 의한 <strong>부분공간의 합</strong> 혹은 <strong>합공간</strong> 이라 한다.</p>
<p><span class="math display">\[
V_1 + \cdots + V_m = \{v_1 + \cdots + v_m : v_1\in V_1,\ldots,\,v_m\in V_m\}
\]</span></p>
</div>
</div>
</div>
</div>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-sum_of_subspace" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.3</strong></span> <span class="math inline">\(V_1 \le V,\, V_2 \le V\)</span> 일 때 <span class="math inline">\(V_1+ V_2 \le V\)</span> 이다. 따라서 <span class="math inline">\(V\)</span> 의 부분공간 <span class="math inline">\(V_1, \ldots,\,V_m\)</span> 의 합공간도 <span class="math inline">\(V\)</span> 의 부분공간이다.</p>
</div>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-directsum" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.7 (직합)</strong></span> <span class="math inline">\(V_1,\,V_2,\ldots,\,V_m\)</span> 이 모두 <span class="math inline">\(V\)</span> 의 부분공간 일 때 <span class="math inline">\(V_0=V_1 + \cdots + V_m\)</span> 라 하자.</p>
<p>모든 <span class="math inline">\(v\in V_0\)</span> 를 <span class="math inline">\(v=v_1 + \cdots + v_m,\, v_i \in V_i,\, i=1,\ldots, m\)</span> 로 나타내는 방법이 한가지 뿐일 때 이를 <span class="math inline">\(V_1,\ldots,\,V_m\)</span> 의 <strong>직합(direct sum)</strong> 이라 하고 <span class="math inline">\(V_1 \oplus \cdots \oplus V_m\)</span> 으로 쓰거나 <span class="math inline">\({\displaystyle \bigoplus_{i=1}^m} V_i\)</span> 로 쓴다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="thm-directsum" class="theorem">
<p><span class="theorem-title"><strong>정리 1.1 (직합의 조건)</strong></span> <span class="math inline">\(V\)</span> 의 부분공간 <span class="math inline">\(V_1,\ldots,\,V_m\)</span> 에 대해 다음은 동치이다.</p>
<p> (<span class="math inline">\(1\)</span>) <span class="math inline">\(V_1+ \cdots + V_m = V_1 \oplus \cdots \oplus V_m\)</span> 이다.</p>
<p> (<span class="math inline">\(2\)</span>) <span class="math inline">\(v_i\in V_i\)</span> 에 대해 <span class="math inline">\(v_1+\cdots + v_m = 0_V\)</span> 인 경우는 <span class="math inline">\(v_1 = \cdots = v_m = 0_V\)</span> 뿐이다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(1 <span class="math inline">\(\implies\)</span> 2) 직합의 정의에 의해 자명하다.</p>
<p>(2 <span class="math inline">\(\implies\)</span> 1) <span class="math inline">\(0_V =v_1 + \cdots + v_m,\, v_i\in V_i\)</span> 이 한가지로만 표현된다고 하자. 만약 어떤 <span class="math inline">\(v\in V\)</span> 가 두가지 방법으로 <span class="math inline">\(v = v_1 + \cdots + v_m = v'_1 + \cdots + v'_m,\, v_i,\, v'_i \in V_i\)</span> 표현된다면 <span class="math inline">\(0_V= (v_1 -v'_1) + \cdots + (v_m - v'_m)\)</span> 이므로 <span class="math inline">\(u_i = u'_i,\, i=1,\ldots, m\)</span> 이다. 즉 <span class="math inline">\(v\)</span> 를 <span class="math inline">\(v_i\)</span> 의 합으로 나타내는 방법은 한가지 뿐이므로 <span class="math inline">\(V_1 + \cdots + V_m\)</span> 은 직합이다. <span class="math inline">\(\square\)</span></p>
</div>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-condition_for_direct_sum" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.4</strong></span> <span class="math inline">\(V_1,\,V_2\)</span> 가 <span class="math inline">\(V\)</span> 의 부분공간일 때 <span class="math inline">\(V_1+ V_2 = V_1\oplus V_2\)</span> 일 필요충분조건은 <span class="math inline">\(V_1 \cap V_2 = \{0_V\}\)</span> 이다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(V_1+V_2 = V_1 \oplus V_2\)</span> 임을 가정하자. <span class="math inline">\(v\in V_1 \cap V_2\)</span> 라면 <span class="math inline">\(v\in V_1,\, (-v)\in V_2\)</span> 이며 <span class="math inline">\(v\ne 0\)</span> 이면 <a href="#thm-directsum" class="quarto-xref">정리&nbsp;<span>1.1</span></a> 에 위배된다. 따라서 <span class="math inline">\(V_1 \cap V_2 = \{0_V\}\)</span> 이다.</p>
<p><span class="math inline">\(V_1 \cap V_2= \{0_V\}\)</span> 라고 하자. 어떤 <span class="math inline">\(v_1\in V_1,\, v_2\in V_2\)</span> 에 대해 <span class="math inline">\(v_1+v_2=0\)</span> 이라고 하자. <span class="math inline">\(v_2=(-v_1)\in V_1\)</span> 이므로 <span class="math inline">\(v_1=v_2=0\)</span> 일 수 밖에 없다. 따라서 <span class="math inline">\(V_1+V_2 = V_1\oplus V_2\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
</section>
<section id="벡터공간의-기저와-차원" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="벡터공간의-기저와-차원"><span class="header-section-number">1.4</span> 벡터공간의 기저와 차원</h2>
<section id="sec-linear_combinatin_and_span" class="level3" data-number="1.4.1">
<h3 data-number="1.4.1" class="anchored" data-anchor-id="sec-linear_combinatin_and_span"><span class="header-section-number">1.4.1</span> 선형결합과 Span</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-linear_combination_and_span" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.8 (선형결합과 Span)</strong></span> <span class="math inline">\(V\)</span> 가 <span class="math inline">\(\mathbb{F}\)</span>-벡터공간 일 때, <span class="math inline">\(a_1,\ldots,\,a_m \in \mathbb{F}\)</span>, <span class="math inline">\(\{v_1,\ldots,\,v_m\}\subset V\)</span> 에 대해</p>
<p><span class="math display">\[
v = a_1 v_1 + \cdots + a_m v_m
\]</span></p>
<p>이라면, <span class="math inline">\(v\)</span> 는 <span class="math inline">\(\{v_1,\ldots,v_m\}\)</span> 의 <strong>선형결합</strong> 이라고 하고, <span class="math inline">\(\{v_1,\ldots,\,v_m\}\)</span> 가 <span class="math inline">\(v\)</span> 를 <strong>span</strong> 한다라고 한다. 또한 <span class="math inline">\(\{v_1,\ldots,\,v_m\}\)</span> 으로 span 할 수 있는 모든 벡터의 집합을 <span class="math inline">\(\text{span} (v_1,\ldots,\,v_m)\)</span> 이라 표현한다. 즉,</p>
<p><span class="math display">\[
\text{span}(v_1,\ldots,\,v_m) = \{a_1v_1 + \cdots + a_m v_m \mid a_1,\ldots,a_m \in \mathbb{F}\}
\]</span></p>
<p>이다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-span_minimal_subspace" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.5</strong></span> <span class="math inline">\(\mathbb{F}\)</span>-벡터공간 <span class="math inline">\(V\)</span> 에 대해 <span class="math inline">\(v_1,\ldots,\,v_m\in V\)</span> 일 때 <span class="math inline">\(\text{span}(v_1,\ldots,\,v_m)\)</span> 은 <span class="math inline">\(V\)</span> 의 부분공간이며 또한 <span class="math inline">\(v_1,\ldots,\,v_m\)</span> 을 포함하는 가장 작은 <span class="math inline">\(V\)</span> 의 부분공간이다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>우선 <span class="math inline">\(V_1\)</span> 이 <span class="math inline">\(v_1,\ldots,\,v_m\)</span> 을 포함하는 <span class="math inline">\(V\)</span> 의 부분공간임을 보이는 것은 쉽다. 어떤 <span class="math inline">\(V\)</span> 의 부분공간 <span class="math inline">\(V_2\)</span> 가 <span class="math inline">\(v_1,\ldots,\,v_m\)</span> 을 포함하는 <span class="math inline">\(V\)</span> 의 부분공간이며, <span class="math inline">\(V_1\)</span> 의 진부분집합이라면 <span class="math inline">\(V_1\)</span> 에는 포함되지만 <span class="math inline">\(V_2\)</span> 에는 포함되지 않는 <span class="math inline">\(v_1,\ldots,v_m\)</span> 의 선형결합이 있어야 하며 이는 <span class="math inline">\(V_2\)</span> 가 벡터공간이라는 것에 위배된다. 따라서 <span class="math inline">\(\text{span}(v_1,\ldots,\,v_m)\)</span> 은 <span class="math inline">\(v_1,\ldots,\,v_m\)</span> 을 포함하는 가장 작은 <span class="math inline">\(V\)</span> 의 부분공간이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-generated_vector_space" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.9 (집합으로 부터 생성된 부분공간)</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 의 부분집합 <span class="math inline">\(U\)</span> 를 생각하자. <span class="math inline">\(U\)</span> 는 부분벡터공간일 수도 있고 아닐 수도 있다. 우리는 <span class="math inline">\(U\)</span> 에 속하는 모든 벡터의 선형결합으로 이루어지는 집합을 생각 할 수 있다. 이 집합을 <span class="math inline">\(U\)</span> 에 의해 <strong>생성된 부분공간</strong> 이라고 한다. 이것을 이제 <span class="math inline">\(\langle U \rangle\)</span> 이라 쓰자. 아직 우리는 이것이 부분공간이라는 것을 보이지 않았지만 쉽게 보일 수 있다.</p>
</div>
</div>
</div>
</div>
<br>
<div class="border" style="background-color:#F0FFFF  ;padding:5px;">
<div id="exr-generated_subspace" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1.1</strong></span> <span class="math inline">\(U\)</span> 가 벡터공간 <span class="math inline">\(V\)</span> 의 부분집합일 때 <span class="math inline">\(\langle U \rangle = \text{span}(U)\)</span> 는 <span class="math inline">\(V\)</span> 의 부분공간임을 보여라. <span class="math inline">\(U\)</span> 가 <span class="math inline">\(V\)</span> 의 부분공간이라면 <span class="math inline">\(U = \langle U \rangle\)</span> 임을 보여라.</p>
</div>
</div>
<p><br></p>
</section>
<section id="유한차원-벡터공간과-무한차원-벡터공간-선형독립과-선형종속" class="level3" data-number="1.4.2">
<h3 data-number="1.4.2" class="anchored" data-anchor-id="유한차원-벡터공간과-무한차원-벡터공간-선형독립과-선형종속"><span class="header-section-number">1.4.2</span> 유한차원 벡터공간과 무한차원 벡터공간, 선형독립과 선형종속</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-finite_dimensional_vector_space" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.10 (유한차원 벡터공간)</strong></span> 벡터 공간 <span class="math inline">\(V\)</span> 를 유한개의 벡터의 span 으로 표현 할 수 있을 때 <span class="math inline">\(V\)</span> 를 <strong>유한차원 벡터공간</strong> 이라 한다. 유한차원 벡터공간이 아닌 벡터공간을 <strong>무한차원 벡터공간</strong> 이라 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-fdvs1" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.13</strong></span> <span class="math inline">\(\mathbb{R}\)</span>-벡터공간 <span class="math inline">\(\mathbb{R}^2\)</span> 를 생각하자. 모든 <span class="math inline">\(r\in \mathbb{R}^2\)</span> 는 <span class="math inline">\((1,\,0)\)</span> 과 <span class="math inline">\((0,\,1)\)</span> 의 선형결합으로 표현 될 수 있다는 것을 보일 수 있다. 따라서 <span class="math inline">\(\mathbb{R}^2\)</span> 는 유한차원 벡터공간이다. <span class="math inline">\(A=\{(x,\,x) : x\in \mathbb{R}\}\)</span> 은 <span class="math inline">\(\mathbb{R}^2\)</span> 의 부분공간이며, <span class="math inline">\((1,\,1)\)</span> 의 선형결합으로 표현할 수 있다. 따라서 <span class="math inline">\(A\)</span> 도 유한차원 벡터공간이다.</p>
</div>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-independency" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.11 (선형독립과 선형종속)</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 의 부분집합 <span class="math inline">\(\{v_1,\ldots,\,v_m\}\)</span> 에 대해</p>
<p><span class="math display">\[
a_1 v_1 + \cdots + a_m v_m = 0_V \implies a_1 = \cdots = a_m = 0
\]</span></p>
<p>이면 <span class="math inline">\(\{v_1,\ldots,\,v_m\}\)</span> 를 <strong>선형 독립</strong>이라 한다. 선형 독립이 아닌 벡터의 집합을 <strong>선형 종속</strong> 이라 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>뒤에 나오겠지만 선형 독립인 벡터의 집합은 벡터공간을 이해하는데 매우 중요하다. 우리는 선형독립인 벡터들에 대해 다음을 보일 수 있다.</p>
<br>
<div class="border" style="background-color:#F0FFFF  ;padding:5px;">
<div id="exr-zero_vector_dependent" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1.2</strong></span> <span class="math inline">\(0\)</span> 벡터가 포함된 벡터의 집합은 선형종속이다.</p>
</div>
</div>
<p><br></p>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span>벡터공간 <span class="math inline">\(V\)</span> 의 임의의 벡터의 집합 <span class="math inline">\(\{v_1,\ldots,\,v_m\}\)</span> 에 대해</p>
<p><span class="math display">\[
c \cdot 0_V + 0 v_1 + \cdots + 0 v_m = 0
\]</span></p>
<p>은 모든 <span class="math inline">\(c\in \mathbb{F}\)</span> 에 대해 성립한다. <span class="math inline">\(\square\)</span></p>
</div>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-unique_span" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.6</strong></span> <span class="math inline">\(\mathbb{F}\)</span>-벡터공간 <span class="math inline">\(V\)</span> 의 부분집합 <span class="math inline">\(\{v_1,\ldots,\,v_n\}\)</span> 이 선형독립이고 <span class="math inline">\(v\in \text{span}(v_1,\ldots,v_n)\)</span> 일 때, <span class="math inline">\(v\)</span> 를 <span class="math inline">\(\{v_1,\ldots,\,v_n\}\)</span> 의 선형결합으로 표현하는 방법은 유일하다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>우선 <a href="#def-independency" class="quarto-xref">정의&nbsp;<span>1.11</span></a> 에 따라 <span class="math inline">\(0_V\)</span> 을 <span class="math inline">\(\{v_1,\ldots,\,v_n\}\)</span> 의 선형결합으로 표현하는 방법이 유일하다. <span class="math inline">\(v\in \text{span}(v_1,\ldots,\,v_n)\)</span> 일 때,</p>
<p><span class="math display">\[
\begin{aligned}
v &amp;= a_1 v_1 + \cdots + a_n v_n \\ &amp;= b_1v_1 + \cdots + b_n v_n
\end{aligned}
\]</span></p>
<p>이라면 <span class="math inline">\((a_1-b_1)v_1 + \cdots (a_n-b_n)v_n = 0_V\)</span> 이므로 <span class="math inline">\(a_1=b_1,\cdots, a_n =b_n\)</span> 이다. 즉, <span class="math inline">\(v\)</span> 를 <span class="math inline">\(\{v_1,\ldots,\,v_n\}\)</span> 의 선형결합으로 표현하는 방법은 유일하다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>이제 벡터들의 집합이 선형 독립인지 종속인지가 그 <span class="math inline">\(\text{span}\)</span> 에 미치는 영향을 알아보자. 우선 <span class="math inline">\(\{v_1,\ldots,\,v_m\}\)</span> 이 선형 종속이라고 하자. <span class="math display">\[
a_1v_1 + \cdots + a_m v_m = 0
\]</span></p>
<p>을 만족시키는 <span class="math inline">\(a_1,\ldots,\,a_m\)</span> 중 <span class="math inline">\(0\)</span> 이 아닌 것이 최소한 하나 이상 포함되어 있다. <span class="math inline">\(a_j \ne 0\)</span> 이라면,</p>
<p><span class="math display">\[
v_j = -\dfrac{1}{a_j} (a_1 v_1 + \cdots + a_{j-1}v_{j-1} + a_{j+1}v_{j+1} + \cdots + a_m v_m)
\]</span></p>
<p>이므로,</p>
<p><span class="math display">\[
\text{span} (v_1, \ldots, v_m) = \text{span} (v_1,\ldots,v_{j-1},\,v_{j+1}, \ldots, v_{m})
\]</span></p>
<p>이다. 우리는 이것을 확장하여 다음을 증명한다.</p>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-vector_dependency_and_span" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.7</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 와 <span class="math inline">\(V_0 = \{v_1,\ldots,\,v_n\} \subset V\)</span> 에 대해 다음은 동치이다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(V_0\)</span> 가 선형 종속이다</p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\(\text{span}(V_0) = \text{span}(V_0-\{v_k\})\)</span> 인 <span class="math inline">\(v_k \in V_0\)</span> 가 존재한다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(1 <span class="math inline">\(\implies\)</span> 2) 앞에서 보였다.</p>
<p>(2 <span class="math inline">\(\implies\)</span> 1) <span class="math inline">\(v_k \in \text{span}(V_0) =\text{span}(V_0-\{v_k\})\)</span> 이므로 <span class="math inline">\(v_k =  c_1 v_1 + \cdots + c_{k-1}v_{k-1}  + c_{k+1}v_{k+1} + \cdots + c_n v_n\)</span> 이다. 따라서 <span class="math inline">\(V_0\)</span> 는 선형 종속이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
위의 명제로부터 다음을 알 수 있다. <br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="cor-vector_independency_and_span" class="theorem corollary">
<p><span class="theorem-title"><strong>따름정리 1.1</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 와 <span class="math inline">\(V_0 = \{v_1,\ldots,\,v_n\} \subset V\)</span> 에 대해 다음은 동치이다.</p>
<p>  (1) <span class="math inline">\(V_0\)</span> 가 선형 독립이다</p>
<p>  (2) 모든 <span class="math inline">\(v_i\in V_0\)</span> 에 대해 <span class="math inline">\(\text{span}(V_0) \ne \text{span}(V_0-\{v_i\})\)</span> 이다.</p>
</div>
</div>
<br>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-linear_dependency_of_polynomials" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.14</strong></span> <span class="math inline">\(\mathbb{F}_n[t]\)</span> 에서 <span class="math inline">\(\{1,\,t,\ldots,\,t^n\}\)</span> 이 선형독립임을 보이자.</p>
<p><span class="math display">\[
a_0 + a_1 t+ \cdots + a_n t^n = 0
\]</span></p>
<p>이라는 것은 모든 <span class="math inline">\(t\in \mathbb{F}\)</span> 에 대해 <span class="math inline">\(p(t) = a_0 + a_1 t + \cdots + a_nt^n=0\)</span> 이라는 의미이다. 가장 쉽게 증명하는 것은 <span class="math inline">\(p(t)\)</span> 가 상수함수이며 무한번 미분 가능한 함수임을 이용하는 것.</p>
</div>
</div>
<p><br></p>
</section>
<section id="벡터공간의-기저-와-순서-기저" class="level3" data-number="1.4.3">
<h3 data-number="1.4.3" class="anchored" data-anchor-id="벡터공간의-기저-와-순서-기저"><span class="header-section-number">1.4.3</span> 벡터공간의 기저 와 순서 기저</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-basis" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.12 (기저)</strong></span> 선형 독립인 <span class="math inline">\(\{v_1,\ldots,\,v_m\}\)</span> 가 벡터공간 <span class="math inline">\(V\)</span> 를 span 할 때 <span class="math inline">\(V\)</span> 의 <strong>기저 (basis)</strong> 라 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>기저의 정의와 <a href="#prp-unique_span" class="quarto-xref">명제&nbsp;<span>1.6</span></a> 으로부터, 다음을 알 수 있다.</p>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-unique" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.8</strong></span> <span class="math inline">\(v\in V\)</span> 를 <span class="math inline">\(V\)</span> 의 기저인 <span class="math inline">\(\{v_1,\ldots,\,v_m\}\)</span> 의 선형결합으로 표현하는 방법은 유일하다.</p>
</div>
</div>
<p><br></p>
<p>보통 집합은 원소가 나열되는 순서가 중요하지 않지만 기저를 다룰 경우 기저를 이루는 벡터의 순서가 중요할 수 있다. 순서가 정해진 기저를 <strong>순서 기저(ordered basis)</strong> 라고 한다. 대부분의 경우 기저를 표현할 때, 기저의 순서가 꼭 필요하지 않더라도 순서기저로 이해해도 상관 없으며 앞으로 특별한 언급이 없을 경우 기저를 순서기저로 간주할 경우 <span class="math inline">\((v_1,\,v_2,\ldots)\)</span> 와 같이 표현하도록 한다. 다만 순서가 중요하지 않을 경우나 혼동의 여지가 없을 경우에는 <span class="math inline">\(\{v_1,\,v_2,\ldots\}\)</span> 와 같이 쓸수도 있도록 하자.</p>
<p><br></p>
</section>
<section id="span-하는-벡터로부터-기저를-추출하기" class="level3" data-number="1.4.4">
<h3 data-number="1.4.4" class="anchored" data-anchor-id="span-하는-벡터로부터-기저를-추출하기"><span class="header-section-number">1.4.4</span> Span 하는 벡터로부터 기저를 추출하기</h3>
<p>유한개의 벡터의 집합 <span class="math inline">\(\{u_1,\ldots,u_m\}\)</span> 이 벡터공간 <span class="math inline">\(V\)</span> 를 span 하면 <span class="math inline">\(V\)</span> 는 유한차원 벡터공간이다. 만약 이 <span class="math inline">\(\{u_i\}\)</span> 가 선형종속이면 적절한 벡터를 제거하여 <span class="math inline">\(V\)</span> 를 span 하게 할 수 있다(<a href="#prp-vector_dependency_and_span" class="quarto-xref">명제&nbsp;<span>1.7</span></a>). 더 이상 제거할 수 없을 때 이 집합은 선형 독립(<a href="#cor-vector_independency_and_span" class="quarto-xref">따름정리&nbsp;<span>1.1</span></a>)이며 <span class="math inline">\(V\)</span> 의 기저이다. 우리는 이로부터 다음을 알 수 있다.</p>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="thm-finitebasis" class="theorem">
<p><span class="theorem-title"><strong>정리 1.2</strong></span> 유한차원 벡터공간은 유한개의 벡터로 이루어진 기저를 갖는다.</p>
</div>
</div>
<p><br> 무한차원 벡터공간이 기저를 갖는다는 것을 선택공리를 통해서 증명할 수 있지만 여기서는 다루지 않는다.</p>
<p><br></p>
</section>
<section id="유한차원-벡터공간의-차원" class="level3" data-number="1.4.5">
<h3 data-number="1.4.5" class="anchored" data-anchor-id="유한차원-벡터공간의-차원"><span class="header-section-number">1.4.5</span> 유한차원 벡터공간의 차원</h3>
<p>우리는 이제 기저(basis) 라는 개념을 통해 어떤 벡터공간은 유한개의 벡터의 선형결합으로 모두 표현할 수 있다는 것을 알게되었다. 기저는 벡터공간을 설명하는데 매우 중요하며 앞으로 벡터와 벡터공간의 성질, 특히 유한차원 벡터공간의 성질은 많은 경우 기저를 이용하여 보이게 된다. 또한 기저를 통해 차원(dimension) 이라는, 벡터공간의 아주 중요한 성질을 말할 수 있게 된다.</p>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="lem-basis_expansion" class="theorem lemma">
<p><span class="theorem-title"><strong>보조정리 1.1</strong></span> 유한차원 벡터공간 <span class="math inline">\(V\)</span> 의 부분집합 <span class="math inline">\(\mathcal{B}_0=\{u_1,\ldots,\,u_m\}\)</span> 이 선형독립일 때 <span class="math inline">\(\mathcal{B}_0\)</span> 를 포함하는 <span class="math inline">\(V\)</span> 의 기저가 존재한다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>우선 선형 독립인 벡터의 집합 <span class="math inline">\(W=\{ w_1,\ldots,\,w_n \}\subset V\)</span> 와 어떤 <span class="math inline">\(v \in V\)</span> 의 합집합이 선형 종속이 되면 <span class="math inline">\(\text{span}(W\cup \{v\}) = \text{span}(W)\)</span> 가 됨을 보이자. <span class="math inline">\(c_1 w_1 + \cdots + c_n w_n + cv = 0\)</span> 라 하자. <span class="math inline">\(c=0\)</span> 이면 <span class="math inline">\(W\)</span> 가 선형 독립이므로 <span class="math inline">\(c_1 = \cdots = c_n=0\)</span> 이며 <span class="math inline">\(W\cup \{v\}\)</span> 가 선형 종속이라는 가정에 위배된다. 따라서 <span class="math inline">\(c\ne 0\)</span> 이며 <span class="math inline">\(v\in \text{span}(W)\)</span> 이다. 즉 <span class="math inline">\(\text{span}(W\cup \{v\}) = \text{span}(W)\)</span> 이다. 즉 선형 독립인 벡터의 집합에 어떤 벡터 벡터를 추가하여 선형 종속이 되면 그 span 에 변화가 없다.</p>
<p><span class="math inline">\(V\)</span> 가 유한차원 벡터공간이므로 <span class="math inline">\(V\)</span> 기저 <span class="math inline">\(V_0 = \{v_1,\ldots,\,v_n\}\)</span> 를 생각 할 수 있다. <span class="math inline">\(\mathcal{B}_i\)</span> 를 <span class="math inline">\(\mathcal{B}_{i-1}\)</span>, <span class="math inline">\(i=1,\ldots,\,n\)</span> 에 대해 다음과 같이 정의하자.</p>
<p><span class="math display">\[
\mathcal{B}_{i} = \left\{\begin{array}{ll}
\mathcal{B}_{i-1} \cup \{v_i\} \qquad &amp; \text{if }\mathcal{B}_{i-1} \cup \{ v_i \} \text{ 가 선형 독립}, \\
\mathcal{B}_{i-1} \qquad &amp; \text{if }\mathcal{B}_{i-1} \cup \{ v_i \} \text{ 가 선형 종속}.
\end{array}\right.
\]</span></p>
<p>이렇게 되면 <span class="math display">\[
\text{span}(\mathcal{B}_n) = \text{span}(\mathcal{B}_{n-1} \cup \{v_i\})  = \cdots = \text{span}(\mathcal{B}_0 \cup \{v_1,\ldots,\,v_i\}) = \text{span}(V_0) = V
\]</span></p>
<p>이므로, <span class="math inline">\(\mathcal{B}_n\)</span> 은 <span class="math inline">\(V\)</span> 의 기저이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>다음 보조정리는 선형독립인 벡터의 집합과 벡터공간을 span 하는 벡터의 집합의 크기에 어떤 관련이 있음을 말한다.</p>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="lem-number_of_basis" class="theorem lemma">
<p><span class="theorem-title"><strong>보조정리 1.2</strong></span> 유한차원 벡터공간 <span class="math inline">\(V\)</span> 에 속하는 선형독립인 벡터 <span class="math inline">\(\{v_1,\ldots,\,v_m\}\)</span> 을 생각하자. 벡터의 집합 <span class="math inline">\(\{u_1,\ldots,\,u_n\}\)</span> 이 <span class="math inline">\(V\)</span> 를 span 할 때, <span class="math inline">\(V\)</span> 에 포함되는 선형독립인 벡터의 갯수는 벡터공간을 span 하는 벡터의 갯수보다 항상 작거나 같다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\mathcal{B}_0=\{u_1,\ldots,\,u_n\}\)</span> 라 하자. <span class="math inline">\(\text{span}(\mathcal{B}_0)=V\)</span> 이므로 <span class="math inline">\(\mathcal{B}_0 \cup \{v_1\}\)</span> 도 <span class="math inline">\(V\)</span> 를 span 한다. 또한 <span class="math inline">\(v_1 \in \text{span}(\mathcal{B}_0)\)</span> 이므로 <span class="math inline">\(\mathcal{B}_0 \cup \{v_1\}\)</span> 은 선형 종속이다. 이제 <span class="math inline">\(\{u_i\}\)</span> 가운데 하나를 <span class="math inline">\(\mathcal{B}_0\cup \{v_1\}\)</span> 에서 제거하여 <span class="math inline">\(V\)</span> 를 span 하도록 할 수 있다. 이것을 <span class="math inline">\(\mathcal{B}_1\)</span> 이라 하자. 이렇게 <span class="math inline">\(V\)</span> 를 span 하는 <span class="math inline">\(\mathcal{B}_i\)</span> 에 <span class="math inline">\(v_i\)</span> 를 넣고 <span class="math inline">\(\mathcal{B}_i\)</span> 에 남아있는 <span class="math inline">\(u_i\)</span> 가운데 span 에 영향을 주지 않는 것을 골라 하나씩 뺄 수 있다. 만약 <span class="math inline">\(n&lt;m\)</span> 이라면 선형독립인 <span class="math inline">\(\{v_1,\ldots,\,v_m\}\)</span> 에서 몇개를 빼서 <span class="math inline">\(V\)</span> 를 span 할 수 있다는 뜻이므로 모순이다. 따라서 <span class="math inline">\(m \le n\)</span> 이다. 즉 <span class="math inline">\(V\)</span> 에서 정의된 선형독립 인 벡터집합의 벡터의 개수는 <span class="math inline">\(V\)</span> 를 span 할 수 있는 벡터의 숫자보다 항장 작거나 같다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>이로부터 우리는 유한차원 벡터공간에 대해 아주 중요한 결론을 얻을 수 있다.</p>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="thm-basis_equality" class="theorem">
<p><span class="theorem-title"><strong>정리 1.3</strong></span> 유한차원 벡터공간 <span class="math inline">\(V\)</span> 의 기저를 이루는 벡터의 개수는 항상 동일하다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\mathcal{B}_1 = (v_1,\ldots,\,v_m)\)</span> 과 <span class="math inline">\(\mathcal{B}_2 = (v'_1,\ldots,\,v'_n)\)</span> 가 유한차원 벡터공간 <span class="math inline">\(V\)</span> 의 기저라 하자. <span class="math inline">\(\mathcal{B}_1\)</span> 이 선형독립인 벡터의 집합이고 <span class="math inline">\(\mathcal{B}_2\)</span> 가 <span class="math inline">\(V\)</span> 를 span 하므로 <span class="math inline">\(m\le n\)</span> 이다. 또한 같은 논리도 <span class="math inline">\(n \le m\)</span> 이다. 즉 <span class="math inline">\(m=n\)</span> 이며, 따라서 두 기저에 포함된 벡터의 갯수는 같다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-dimension" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.13 (벡터공간의 차원)</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 의 기저에 포함된 벡터의 개수를 <span class="math inline">\(V\)</span> 의 <strong>차원(dimension)</strong> 이라고 하며 <span class="math inline">\(\dim (V)\)</span> 로 표현한다.</p>
</div>
</div>
</div>
</div>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="cor-dim_subspace" class="theorem corollary">
<p><span class="theorem-title"><strong>따름정리 1.2</strong></span> <span class="math inline">\(W\)</span> 가 <span class="math inline">\(V\)</span> 의 부분공간이면 <span class="math inline">\(\dim (W) \le \dim (V)\)</span> 이고 <span class="math inline">\(\dim (W)= \dim (V)\)</span> 이면 <span class="math inline">\(V=W\)</span> 이다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(W\)</span> 가 <span class="math inline">\(V\)</span> 의 부분공간 일 때 <span class="math inline">\(W\)</span> 의 어떤 기저 <span class="math inline">\(\mathcal{B}_W\)</span> 를 잡았다면, 이 <span class="math inline">\(\mathcal{B}_W\)</span> 는 <span class="math inline">\(V\)</span> 에 포함되는 선형독립인 벡터이므로 여기에 선형독립이 되도록 벡터를 추가하여 <span class="math inline">\(V\)</span> 의 기저를 구성 할 수 있다. 따라서 <span class="math inline">\(W\)</span> 가 <span class="math inline">\(V\)</span> 의 부분공간이면</p>
<p><span class="math display">\[
\dim (W) \le \dim (V)
\]</span></p>
<p>이다. <span class="math inline">\(\dim (W)=\dim (V)\)</span> 이면 <span class="math inline">\(W\)</span> 의 기저가 <span class="math inline">\(V\)</span> 의 기저가 되므로 <span class="math inline">\(W=V\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<br>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-dimension_of_matrix_space" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.15</strong></span> 우리는 <a href="#exm-vectorspace_matrix" class="quarto-xref">보기&nbsp;<span>1.5</span></a> 에서 <span class="math inline">\(\mathbb{F}\)</span> 의 의 원소를 성분으로 갖는 행렬의 집합 <span class="math inline">\(\mathcal{M}_{m\times n}(\mathbb{F})\)</span> 가 벡터공간이라는 것을 알았다. <span class="math inline">\(1 \le i \le m\)</span>, <span class="math inline">\(1 \le j \le n\)</span> 에 대해 <span class="math inline">\(\boldsymbol{E}^{(i,j)}\)</span> 을 <span class="math inline">\(i\)</span> 행 <span class="math inline">\(j\)</span> 열 성분은 <span class="math inline">\(1\)</span> 이며 나머지 성분은 모두 <span class="math inline">\(0\)</span> 인 <span class="math inline">\(m \times n\)</span> 행렬이라 하자. 즉 <span class="math inline">\(\mathbb{F}^{2 \times 3}\)</span> 에서 <span class="math inline">\(\boldsymbol{E}^{(2, 1)} = \begin{bmatrix} 0 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 0\end{bmatrix}\)</span> 이다. <span class="math inline">\(\mathbb{F}^{m \times n}\)</span> 에서 <span class="math inline">\(\mathcal{B}=\left\{\boldsymbol{E}^{(i, j)} : 1\le i \le m,\, 1 \le j \le n\right\}\)</span> 는 선형독립이다. 또한 <span class="math inline">\(\mathcal{B}\)</span> 가 <span class="math inline">\(\mathcal{M}_{m\times n}(\mathbb{F})\)</span> 을 span 한다. <span class="math inline">\(\mathcal{B}\)</span> 의 원소의 갯수는 <span class="math inline">\(mn\)</span> 이므로 <span class="math inline">\(\dim (\mathcal{M}_{m\times n}(\mathbb{F}))=mn\)</span> 이다.</p>
</div>
</div>
<p><br></p>
</section>
<section id="합공간의-차원" class="level3" data-number="1.4.6">
<h3 data-number="1.4.6" class="anchored" data-anchor-id="합공간의-차원"><span class="header-section-number">1.4.6</span> 합공간의 차원</h3>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-dim_sum" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.9</strong></span> <span class="math inline">\(U_1,\,U_2\)</span> 가 유한차원 부분공간 <span class="math inline">\(V\)</span> 의 부분공간일 때 다음이 성립한다. <span class="math display">\[
\dim (U_1 + U_2) = \dim (U_1) + \dim (U_2) - \dim (U_1 \cap U_2).
\]</span></p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>두 벡터공간 <span class="math inline">\(U,\,V\)</span> 의 교집합은 <span class="math inline">\(U\)</span> 와 <span class="math inline">\(V\)</span> 각각의 부분공간이다. (즉 벡터공간이다. <a href="#exm-intersection_of_two_spaces" class="quarto-xref">보기&nbsp;<span>1.9</span></a>) <span class="math inline">\(\dim (U_1 \cap U_2) = m\)</span> 이라 할 때 <span class="math inline">\(U_1 \cap U_2\)</span> 의 기저 <span class="math inline">\(\{w_1,\ldots,\,w_m\}\)</span> 을 잡는다. 이를 확장하여 <span class="math inline">\(U_1\)</span> 의 기저 <span class="math inline">\(\{w_1,\ldots,\,w_m,\,u_1,\ldots,\,u_k\}\)</span> 와 <span class="math inline">\(U_2\)</span> 의 기저 <span class="math inline">\(\{ w_1,\ldots,\,w_m,\,u_1,\ldots,u_n \}\)</span> 을 구성 할 수 있다.</p>
<p><span class="math inline">\(\dim (U_1) = m+k\)</span>, <span class="math inline">\(\dim (U_2) = m+n\)</span> 이며 <span class="math inline">\(\dim (U_1+U_2)= m+n+k\)</span> 이므로 위의 식이 성립한다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
이로부터 다음 명제가 자연스럽게 유도된다. <br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-dimension_of_direct_sum" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.10</strong></span> 유한차원 벡터공간 <span class="math inline">\(V\)</span> 와 그 부분공간 <span class="math inline">\(U_1,\,U_2\)</span> 에 대해 <span class="math inline">\(V=U_1\oplus U_2\)</span> 이면 <span class="math inline">\(\dim (V) = \dim(U_1) + \dim (U_2)\)</span> 이다.</p>
</div>
</div>
<p><br></p>
</section>
</section>
<section id="벡터의-행렬표현" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="벡터의-행렬표현"><span class="header-section-number">1.5</span> 벡터의 행렬표현</h2>
<p>여기서는 벡터를 행렬로 표현하는 방법에 대해 다룬다.</p>
<section id="벡터의-행렬표현-1" class="level3" data-number="1.5.1">
<h3 data-number="1.5.1" class="anchored" data-anchor-id="벡터의-행렬표현-1"><span class="header-section-number">1.5.1</span> 벡터의 행렬표현</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-matrix_representation_of_vector" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.14 (벡터의 행렬표현과 좌표)</strong></span> <span class="math inline">\(n\)</span> 차원 <span class="math inline">\(\mathbb{F}\)</span>-벡터공간 <span class="math inline">\(V\)</span> 의 어떤 <a href="#벡터공간의-기저-basis-와-순서-기저-ordered-basis">순서기저</a> <span class="math inline">\(\mathcal{B} = (v_i)\)</span> 에 대해 <span class="math inline">\(v=\sum_i a_i v_i\)</span> 라고 하자. 이 때 <span class="math inline">\(v\in V\)</span> 를 <span class="math inline">\(\mathcal{B}\)</span> 기저에 대해 <span class="math inline">\(n \times 1\)</span> 행렬로 다음과 같이 표현하는 것을 벡터 <span class="math inline">\(v\)</span> 의 기저 <span class="math inline">\(\mathcal{B}\)</span> 에 대한 <strong>행렬 표현</strong> 이라 하고 <span class="math inline">\([v]_{\mathcal{B}}\)</span> 라 표기한다.</p>
<p><span class="math display">\[
[v]_\mathcal{B} = \begin{bmatrix} a_1 \\ \vdots \\ a_n\end{bmatrix}
\]</span></p>
<p>이 때 <span class="math inline">\((a_1,\ldots,\,a_n)\)</span> 을 <span class="math inline">\(v\)</span> 의 <span class="math inline">\(\mathcal{B}\)</span> 기저에서의 <strong>좌표(coordinate)</strong> 라 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><span class="math inline">\(n\)</span> 차원 벡터를 행렬로 표형할때는 일반적으로 위와 같은 <span class="math inline">\(n \times 1\)</span> 행렬를 사용한다. 또한 열벡터를 아래에서 위로 길게 보이는 것을 피하기 위해 <span class="math inline">\([v]_\mathcal{B} = \begin{bmatrix} a_1 &amp; \cdots &amp; a_n \end{bmatrix}^T\)</span> 처럼 전치행렬을 사용하여 표현하기도 한다. 여기서 항상 조심해야 할 것은 벡터의 행렬표현은 특정한 순서기저에서의 행렬표현라는 것이다. 기저가 바뀌면 행렬표현도 바뀐다.</p>
<p><br></p>
</section>
<section id="열벡터와-표준-기저" class="level3" data-number="1.5.2">
<h3 data-number="1.5.2" class="anchored" data-anchor-id="열벡터와-표준-기저"><span class="header-section-number">1.5.2</span> 열벡터와 표준 기저</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-standard_basis" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1.15 (표준기저와 표준기저벡터)</strong></span> 유클리드공간 <span class="math inline">\(\mathbb{F}^{n}\)</span> 에서의 <strong>표준기저벡터</strong> <span class="math inline">\(\hat{e}_i\)</span> 는 <span class="math inline">\(i\)</span> 번째 성분은 1이고 나머지 성분은 0 인 벡터이다. 즉 <span class="math inline">\(\hat{e}_i\)</span> 의 <span class="math inline">\(j\)</span>-번째 성분 <span class="math inline">\((\hat{e}_i)_j\)</span> 는</p>
<p><span class="math display">\[
(\hat{e}_i)_{j} = \delta_{ij}
\]</span></p>
<p>가 된다. 즉 <span class="math inline">\(\mathbb{R}^3\)</span> 에서의 <span class="math inline">\(\hat{e}_2=(0, 1, 0)\)</span> 이다. <span class="math inline">\(\mathbb{F}^n\)</span> 에서의 표준 기저 벡터의 집합 <span class="math inline">\(\{\hat{e}_1,\,\hat{e}_2,\ldots,\,\hat{e}_n\}\)</span> 은 <span class="math inline">\(\mathbb{F}^n\)</span> 의 기저이다. 이 기저를 <strong>표준기저 (standard basis)</strong> 라고 한다.</p>
<p>열벡터의 벡터공간 <span class="math inline">\(\mathcal{M}_n (\mathbb{F})\)</span> 의 표준기저벡터 <span class="math inline">\(\boldsymbol{e}_i\)</span> 는 <span class="math inline">\(i\)</span> 번째 성분만 <span class="math inline">\(1\)</span> 이며 나머지 성분은 <span class="math inline">\(0\)</span> 인 <span class="math inline">\(n \times 1\)</span> 행렬이다. <span class="math inline">\(\mathbb{F}^n\)</span> 에서와 마찬가지로 <span class="math inline">\(\{\boldsymbol{e}_1,\ldots,\boldsymbol{e}_n\}\)</span> 이 <span class="math inline">\(\mathcal{M}_{n}(\mathbb{F})\)</span> 의 기저이며 이를 <span class="math inline">\(\mathcal{M}_n(\mathbb{F})\)</span> 의 표준기저라고 한다.</p>
</div>
</div>
</div>
</div>
<br>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-standard_basis" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.16</strong></span> 위에서 정의한 표준기저가 실제 벡터공간 <span class="math inline">\(\mathbb{F}^{n}\)</span> 의 기저임을 보여라.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-stadard_basis_2" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.17</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 의 기저 <span class="math inline">\(\mathcal{B}_V=(v_i)\)</span> 에 대해 기저의 행렬표현은 표준기저이다. 즉 <span class="math inline">\([v_i]_{\mathcal{B}_V} = \boldsymbol{e}_i\)</span> 이다.</p>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-matrix_representation_of_vectors" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.18</strong></span> <span class="math inline">\(\mathbb{R}^2\)</span> 에서 <span class="math inline">\(\mathcal{B}_1 = ((1, 0),\, (0, 1))\)</span> 이 표준기저이다. 이 이외에도 <span class="math inline">\(\mathcal{B}_2 = ( (1, 1),\, (1, -1) )\)</span> 도 기저가 될 수 있다. <span class="math inline">\(v=(3,\,1)\)</span> 은 <span class="math inline">\(3(1, 0) + 1(0,1)\)</span> 이므로 <span class="math inline">\([v]_{\mathcal{B}_1}=\begin{bmatrix} 3 \\ 1\end{bmatrix}\)</span> 이다. 또한 <span class="math inline">\(v=2(1,1)+(1, -1)\)</span> 이므로 <span class="math inline">\([v]_{\mathcal{B}_2} =\begin{bmatrix} 2 \\ 1 \end{bmatrix}\)</span> 이다.</p>
</div>
</div>
<br>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-sum_of_vector_in_matrix_representation" class="theorem example">
<p><span class="theorem-title"><strong>보기 1.19</strong></span> <span class="math inline">\(n\)</span> 차원 벡터공간 <span class="math inline">\(V\)</span> 에 대해 <span class="math inline">\(u,\,v\in V,\,c \in \mathbb{F}\)</span> 라 하자. <span class="math inline">\(V\)</span> 의 한 순서기저 <span class="math inline">\(\mathcal{B} = (v_1,\ldots,v_n)\)</span> 에 대해 <span class="math inline">\(v=\sum_i a_i v_i\)</span>, <span class="math inline">\(u=\sum_i b_i v_i\)</span> 일 때,</p>
<p><span class="math display">\[
[u+c v]_{\mathcal{B}} = \left[\sum_{i} (a_i + c b_i) v_i \right]_{\mathcal{B}} = \begin{bmatrix} a_1 + c b_i \\ \vdots \\ a_n + c b_n\end{bmatrix}
\]</span></p>
<p>이다.</p>
</div>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-warning no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>우리는 아직 행렬의 덧셈을 정의하지 않았고 단지 두 벡터의 합과 스칼라곱이 벡터의 행렬표현에서 어떻게 되는지를 알아본 것이다. 위의 <a href="#exm-sum_of_vector_in_matrix_representation" class="quarto-xref">보기&nbsp;<span>1.19</span></a> 을 잘 보면 (최소한) <span class="math inline">\(n\times 1\)</span> 행렬의 덧셈과 스칼라곱을 어떻게 자연스럽게 정의 할 수 있을지 판단 할 수 있을 것이다. 다음 장에서 일반적인 행렬의 덧셈과 스칼라곱을 제대로 정의 할 것이다.</p>
</div>
</div>
</div>
<p><br></p>
</section>
</section>
<section id="연습문제" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="연습문제">연습문제</h2>
<div class="border" style="background-color:#F0FFFF  ;padding:5px;">
<div id="exr-union_of_two_subspaces" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1.3</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 의 두 부분공간 <span class="math inline">\(U_1\)</span>, <span class="math inline">\(U_2\)</span> 에 대해 <span class="math inline">\((U_1 \cup U_2) \le V\)</span> 일 필요충분조건은 <span class="math inline">\(U_1 \le U_2\)</span> 이거나 <span class="math inline">\(U_2 \le U_1\)</span> 인 것을 보여라.</p>
</div>
</div>
<p><br></p>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span><span class="math inline">\(U_1 \le U_2\)</span> 일 때 <span class="math inline">\((U_1 \cup U_2) \le V\)</span> 인 것은 자명하다. <span class="math inline">\(u_1 \in U_1-U_2,\, u_2\in U_2-U_1\)</span> 이라 하자. <span class="math inline">\(u_1+u_2 \not\in U_1 \cup U_2\)</span> 이므로 <span class="math inline">\(U_1 \cup U_2\)</span> 는 부분공간이 될 수 없다.</p>
</div>
<br>
<div class="border" style="background-color:#F0FFFF  ;padding:5px;">
<div id="exr-basis_or_direct_sum" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 1.4</strong></span> <span class="math inline">\(U, V\)</span> 가 벡터공간 <span class="math inline">\(W\)</span> 의 부분공간이며 <span class="math inline">\(W=U \oplus V\)</span> 라고 하자. <span class="math inline">\((u_1,\ldots,\,u_n)\)</span> 이 <span class="math inline">\(U\)</span> 의 기저이고 <span class="math inline">\((v_1, \ldots,\,v_m)\)</span> 이 <span class="math inline">\(V\)</span> 의 기저이면 <span class="math inline">\((u_1,\ldots,\,u_n,\,v_1,\ldots,\,v_m)\)</span> 은 <span class="math inline">\(W\)</span> 의 기저임을 보여라.</p>
</div>
</div>
<p><br></p>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span>직합의 조건에 의해 <span class="math inline">\(0=u+v,\,u\in U,\,v\in V\)</span> 는 <span class="math inline">\(u=v=0\)</span> 뿐이다. 따라서 <span class="math inline">\((u_1,\ldots,\,u_n,\,v_1,\ldots,\,v_m)\)</span> 은 선형독립이므로 <span class="math inline">\(U\oplus V\)</span> 의 기저이다.</p>
</div>
<p><br></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../src/part1/part1.html" class="pagination-link" aria-label="I. 선형대수학의 기초 : 벡터공간에서 특이값 분해까지">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">I. 선형대수학의 기초 : 벡터공간에서 특이값 분해까지</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../src/part1/ch1_02_linear_map.html" class="pagination-link" aria-label="선형사상">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">선형사상</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>