<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; 가우스 조단 소거법과 행렬식 – 대수학</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../src/part1/ch1_06_eigenvalue.html" rel="next">
<link href="../../src/part1/ch1_02_linear_map.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/part1/part1.html">I. 선형대수학의 기초 : 벡터공간에서 특이값 분해까지</a></li><li class="breadcrumb-item"><a href="../../src/part1/ch1_03_determinant.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">가우스 조단 소거법과 행렬식</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">대수학</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../src/part1/part1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">I. 선형대수학의 기초 : 벡터공간에서 특이값 분해까지</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_01_vectorspace.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">벡터와 벡터공간</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_02_linear_map.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">선형사상</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_03_determinant.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">가우스 조단 소거법과 행렬식</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_06_eigenvalue.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">고유값과 고유벡터</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_07_innerproduct.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">내적</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_08_operators_on_innerproduct_space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">내적벡터공간에서의 연산자</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_09_spectrum_theorem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">스펙트럼 정리</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part1/ch1_10_svd.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">특이값 분해</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../src/part2/part2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">II. 군 (Groups)</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part2/ch2_01_groups.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">군의 기초</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part2/ch2_02_homomorphisms.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">군에서의 준동형사상과 동형사상</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part2/ch2_03_normal_subgroup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">정규부분군과 몫군</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part2/ch2_04_symmetry.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Symmetry</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../src/part3/part3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">III. 심화 선형대수학</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/quotient_space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">몫공간과 몫사상</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/dual_space.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">쌍대공간과 쌍대 사상</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/bilinear_form.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">다중선형 형식</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/laplacian_form_of_determinant.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">행렬식의 라플라시안 형식</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/generalized_inverse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">일반화된 역행렬과 유사역행렬</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/characteristic_polynomial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">특성다항식, 최소다항식과 케일리-해밀턴 정리</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/generalized_eigenspace.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">일반화된 고유공간과 조르당 형식</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/part3/tensor_product.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">텐서곱</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#sec-elementary_row_operation" id="toc-sec-elementary_row_operation" class="nav-link active" data-scroll-target="#sec-elementary_row_operation"><span class="header-section-number">3.1</span> 기본 행 연산</a>
  <ul class="collapse">
  <li><a href="#기본-행-연산의-정의와-행렬표현" id="toc-기본-행-연산의-정의와-행렬표현" class="nav-link" data-scroll-target="#기본-행-연산의-정의와-행렬표현"><span class="header-section-number">3.1.1</span> 기본 행 연산의 정의와 행렬표현</a></li>
  <li><a href="#기본-행-연산의-행렬-표현" id="toc-기본-행-연산의-행렬-표현" class="nav-link" data-scroll-target="#기본-행-연산의-행렬-표현"><span class="header-section-number">3.1.2</span> 기본 행 연산의 행렬 표현</a></li>
  </ul></li>
  <li><a href="#행-사다리꼴-행렬과-행-간소-사다리꼴-행렬" id="toc-행-사다리꼴-행렬과-행-간소-사다리꼴-행렬" class="nav-link" data-scroll-target="#행-사다리꼴-행렬과-행-간소-사다리꼴-행렬"><span class="header-section-number">3.2</span> 행 사다리꼴 행렬과 행 간소 사다리꼴 행렬</a>
  <ul class="collapse">
  <li><a href="#sec-row_echelon_matrix" id="toc-sec-row_echelon_matrix" class="nav-link" data-scroll-target="#sec-row_echelon_matrix"><span class="header-section-number">3.2.1</span> 행 사다리꼴 행렬</a></li>
  <li><a href="#sec-reduced_raw_echelon_matrix" id="toc-sec-reduced_raw_echelon_matrix" class="nav-link" data-scroll-target="#sec-reduced_raw_echelon_matrix"><span class="header-section-number">3.2.2</span> 행 간소 사다리꼴 행렬</a></li>
  </ul></li>
  <li><a href="#대칭군" id="toc-대칭군" class="nav-link" data-scroll-target="#대칭군"><span class="header-section-number">3.3</span> 대칭군</a>
  <ul class="collapse">
  <li><a href="#순열의-표기" id="toc-순열의-표기" class="nav-link" data-scroll-target="#순열의-표기"><span class="header-section-number">3.3.1</span> 순열의 표기</a></li>
  <li><a href="#순열의-분해" id="toc-순열의-분해" class="nav-link" data-scroll-target="#순열의-분해"><span class="header-section-number">3.3.2</span> 순열의 분해</a></li>
  <li><a href="#순열에-대한-textsgn-함수" id="toc-순열에-대한-textsgn-함수" class="nav-link" data-scroll-target="#순열에-대한-textsgn-함수"><span class="header-section-number">3.3.3</span> 순열에 대한 <span class="math inline">\(\text{sgn}\)</span> 함수</a></li>
  </ul></li>
  <li><a href="#sec-determinant_definition_using_symmetric_group" id="toc-sec-determinant_definition_using_symmetric_group" class="nav-link" data-scroll-target="#sec-determinant_definition_using_symmetric_group"><span class="header-section-number">3.4</span> 대칭군을 이용한 행렬식</a>
  <ul class="collapse">
  <li><a href="#행렬식의-정의" id="toc-행렬식의-정의" class="nav-link" data-scroll-target="#행렬식의-정의"><span class="header-section-number">3.4.1</span> 행렬식의 정의</a></li>
  <li><a href="#det-함수의-기본적인-성질" id="toc-det-함수의-기본적인-성질" class="nav-link" data-scroll-target="#det-함수의-기본적인-성질"><span class="header-section-number">3.4.2</span> <span class="math inline">\(\det\)</span> 함수의 기본적인 성질</a></li>
  <li><a href="#sec-determinant" id="toc-sec-determinant" class="nav-link" data-scroll-target="#sec-determinant"><span class="header-section-number">3.4.3</span> 행렬식</a></li>
  </ul></li>
  <li><a href="#다양한-행렬의-행렬식" id="toc-다양한-행렬의-행렬식" class="nav-link" data-scroll-target="#다양한-행렬의-행렬식"><span class="header-section-number">3.5</span> 다양한 행렬의 행렬식</a>
  <ul class="collapse">
  <li><a href="#기본적인-행렬과-행렬식" id="toc-기본적인-행렬과-행렬식" class="nav-link" data-scroll-target="#기본적인-행렬과-행렬식"><span class="header-section-number">3.5.1</span> 기본적인 행렬과 행렬식</a></li>
  <li><a href="#sec-basic_properties_of_matrix" id="toc-sec-basic_properties_of_matrix" class="nav-link" data-scroll-target="#sec-basic_properties_of_matrix"><span class="header-section-number">3.5.2</span> 행렬에 대한 몇가지 기본적인 성질들</a></li>
  <li><a href="#블록-행렬의-행렬식" id="toc-블록-행렬의-행렬식" class="nav-link" data-scroll-target="#블록-행렬의-행렬식"><span class="header-section-number">3.5.3</span> 블록 행렬의 행렬식</a></li>
  </ul></li>
  <li><a href="#sec-linear_map_understood_by_RREM" id="toc-sec-linear_map_understood_by_RREM" class="nav-link" data-scroll-target="#sec-linear_map_understood_by_RREM"><span class="header-section-number">3.6</span> 행간소 사다리꼴 행렬을 통한 선형사상의 이해</a>
  <ul class="collapse">
  <li><a href="#sec-row_space_and_column_space" id="toc-sec-row_space_and_column_space" class="nav-link" data-scroll-target="#sec-row_space_and_column_space"><span class="header-section-number">3.6.1</span> 행공간과 열공간</a></li>
  <li><a href="#sec-rank_of_matrix" id="toc-sec-rank_of_matrix" class="nav-link" data-scroll-target="#sec-rank_of_matrix"><span class="header-section-number">3.6.2</span> 행렬의 rank</a></li>
  <li><a href="#sec-uniqueness_of_reduced_row_echelon_form" id="toc-sec-uniqueness_of_reduced_row_echelon_form" class="nav-link" data-scroll-target="#sec-uniqueness_of_reduced_row_echelon_form"><span class="header-section-number">3.6.3</span> 행 간소 사다리꼴의 유일성</a></li>
  <li><a href="#sec-reduced_row_echelon_form_of_inverse_matrix" id="toc-sec-reduced_row_echelon_form_of_inverse_matrix" class="nav-link" data-scroll-target="#sec-reduced_row_echelon_form_of_inverse_matrix"><span class="header-section-number">3.6.4</span> 가역행렬의 행 간소 사다리꼴, 역행렬 과 행렬식</a></li>
  <li><a href="#sec-triangular_matrix" id="toc-sec-triangular_matrix" class="nav-link" data-scroll-target="#sec-triangular_matrix"><span class="header-section-number">3.6.5</span> 삼각행렬의 성질</a></li>
  </ul></li>
  <li><a href="#연습문제" id="toc-연습문제" class="nav-link" data-scroll-target="#연습문제"><span class="header-section-number">3.7</span> 연습문제</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/part1/part1.html">I. 선형대수학의 기초 : 벡터공간에서 특이값 분해까지</a></li><li class="breadcrumb-item"><a href="../../src/part1/ch1_03_determinant.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">가우스 조단 소거법과 행렬식</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">가우스 조단 소거법과 행렬식</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><br></p>
<p>이제 가우스 조단 소거법에 대해 알아보자. 가우스 조단 소거법을 통해 행 간소 사다리꼴을 구하는 것은 선형방정식을 푸는 것 뿐만 아니라 행렬의 여러가지 성질에 대한 통찰을 줄 수 있다. 또한 행렬식을 통해 정사각행렬의 다양한 성질에 대해 알아볼 것이다. 대표적으로 행렬식은 어떤 행렬이 가역인지 아닌지를 쉽게 보일 수 있다.</p>
<p><br></p>
<section id="sec-elementary_row_operation" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-elementary_row_operation"><span class="header-section-number">3.1</span> 기본 행 연산</h2>
<section id="기본-행-연산의-정의와-행렬표현" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="기본-행-연산의-정의와-행렬표현"><span class="header-section-number">3.1.1</span> 기본 행 연산의 정의와 행렬표현</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-elementary_row_operation" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.1 (기본 행 연산)</strong></span> 행렬에 대한 다음 세 연산을 <strong>기본 행 연산 (elementary row operation)</strong> 이라 한다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(E^{(1)}(i,j)\)</span> : <span class="math inline">\(i\)</span> 행과 <span class="math inline">\(j\)</span> 행의 위치를 바꾼다.</p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\(E^{(2)}(i, t)\)</span> : <span class="math inline">\(i\)</span> 행에 <span class="math inline">\(0\)</span> 이 아닌 스칼라 <span class="math inline">\(t \in \mathbb{F}\)</span> 를 곱한다.</p>
<p>  (<span class="math inline">\(3\)</span>) <span class="math inline">\(E^{(3)}(i, j, r)\)</span> : <span class="math inline">\(i\)</span> 행에 <span class="math inline">\(j\)</span> 번째 행의 <span class="math inline">\(r\in \mathbb{F}\)</span> 배를 더한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 <span class="math inline">\(i\)</span> 번째 행을 <span class="math inline">\(\boldsymbol{A}_{i:}\)</span> 라고 하자. 3번째 연산의 결과로 변환된 행렬을 <span class="math inline">\(\boldsymbol{A}'\)</span> 이라 하면,</p>
<p><span class="math display">\[
\boldsymbol{A}'_{i:} = \boldsymbol{A}_{i:} + r \boldsymbol{A}_{j:},\qquad \boldsymbol{A}'_{j:} = \boldsymbol{A}_{j:}
\]</span></p>
<p>이다.</p>
<p><br></p>
<div id="prp-elementary_row_operation" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.1</strong></span> 기본행 연산은 행렬에 대한 선형 연산이며, 가역연산이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>기본행 연산은 <span class="math inline">\(E:\mathcal{M}_{m \times n}(\mathbb{F}) \mapsto \mathcal{M}_{m \times n}(\mathbb{F})\)</span> 함수로서 <span class="math inline">\(\boldsymbol{A},\,\boldsymbol{B}\in \mathcal{M}_{m \times n}(\mathbb{F})\)</span>, <span class="math inline">\(c\in \mathbb{F}\)</span> 에 대해 <span class="math inline">\(E(\boldsymbol{A}+c\boldsymbol{B}) = E(\boldsymbol{A}) + cE(\boldsymbol{B})\)</span> 이다. <span class="math inline">\(\left(E^{(1)}(i, j)\right)^{-1} = E^{(1)}(i, j)\)</span> 이며, <span class="math inline">\(\left(E^{(2)}(i, t)\right)^{-1} = E^{(2)}(i, 1/t)\)</span> 이고 <span class="math inline">\(\left(E^{(3)}(i, j, r)\right)^{-1} = E^{(3)}(i, j, -r)\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
<section id="기본-행-연산의-행렬-표현" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="기본-행-연산의-행렬-표현"><span class="header-section-number">3.1.2</span> 기본 행 연산의 행렬 표현</h3>
<p>기본 행 연산은 선형 연산이기 때문에 행렬로 표현 할 수 있다. 행 연산에 대한 표기로 <span class="math inline">\(E^{(i)}\)</span> 를 사용했는데 이와 유사하게 이의 행렬 표기를 <span class="math inline">\(\boldsymbol{E}^{(i)}\)</span> 로 한다. 또한 <span class="math inline">\(\boldsymbol{I}_{k:}\)</span> 는 단위행렬의 <span class="math inline">\(k\)</span> 번째 행벡터를 의미한다.</p>
<p>(<span class="math inline">\(1\)</span>) <span class="math inline">\(\boldsymbol{E}^{(1)}(i, j)\)</span> 의 <span class="math inline">\(k\)</span> 번째 행은 다음 식으로 결정된다.</p>
<p><span class="math display">\[
\boldsymbol{E}^{(1)}(i, j)_{k:} = (1-\delta_{ik})(1-\delta_{jk})\boldsymbol{I}_{k:} + \delta_{ik}\boldsymbol{I}_{j:} + \delta_{jk}\boldsymbol{I}_{i:}
\]</span></p>
<p><span class="math inline">\(i\)</span> 행과 <span class="math inline">\(j\)</span> 행, <span class="math inline">\(i\)</span> 열과 <span class="math inline">\(j\)</span> 열을 제외한 모든 성분은 항등행렬의 성분과 같기 때문에 이 두 행과 열만을 표현하면 다음과 같다.</p>
<p><span class="math display">\[
\boldsymbol{E}^{(1)} (i, j) = \begin{bmatrix} 0 &amp; &amp; 1  \\ &amp; \ddots &amp; \\ 1 &amp; &amp; 0  \end{bmatrix}
\]</span></p>
<p>(<span class="math inline">\(2\)</span>) <span class="math inline">\(\boldsymbol{E}^{(2)}(i, t)\)</span> 의 <span class="math inline">\(k\)</span> 번째 행은 다음 식으로 결정된다.</p>
<p><span class="math display">\[
\boldsymbol{E}^{(2)}(i, t)_{k:} = (1-\delta_{ik})\boldsymbol{I}_{k:} + t\delta_{ik} \boldsymbol{I}_{k:}
\]</span></p>
<p>즉 <span class="math inline">\(\boldsymbol{E}_{ii}=t\)</span> 이고 나머지 성분은 항등행렬과 같다.</p>
<p>(<span class="math inline">\(3\)</span>). <span class="math inline">\(\boldsymbol{E}^{(3)}(i, j, r)\)</span> 의 <span class="math inline">\(k\)</span> 번째 행은 다음 식으로 결정된다.</p>
<p><span class="math display">\[
\boldsymbol{E}^{(3)}(i, j, r)_{k:} = \boldsymbol{I}_{k:} + r\delta_{ik} \boldsymbol{I}_{j:}
\]</span></p>
<p><span class="math inline">\(i\)</span> 행과 <span class="math inline">\(j\)</span> 행, <span class="math inline">\(i\)</span> 열과 <span class="math inline">\(j\)</span> 열을 제외한 모든 성분은 항등행렬의 성분과 같기 때문에 이 두 행과 열만을 표현하면 다음과 같다.</p>
<p><span class="math display">\[
\begin{aligned}
\boldsymbol{E}^{(3)} (i, j, r) &amp;= \begin{bmatrix} 1 &amp; &amp; r\\ &amp; \ddots &amp; \\  &amp; &amp; 1 \end{bmatrix} &amp; i&lt;j \\
\boldsymbol{E}^{(3)} (i, j, r) &amp;= \begin{bmatrix} 1 &amp; &amp; \\ &amp; \ddots &amp; \\ r &amp; &amp; 1 \end{bmatrix}  &amp; i&gt;j
\end{aligned}
\]</span></p>
<p><br></p>
<p>기본행 연산은 가역연산 이므로 이에 대한 행렬은 가역행렬이다. <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{m \times n}(\mathbb{F})\)</span>, <span class="math inline">\(\boldsymbol{B}\in \mathcal{M}_{m \times m}(\mathbb{F})\)</span>, <span class="math inline">\(\boldsymbol{u}\in \mathcal{M}_n(\mathbb{F})\)</span>, <span class="math inline">\(\boldsymbol{v}\in \mathcal{M}_m(\mathbb{F})\)</span> 에 대해 <span class="math inline">\(\boldsymbol{B}\)</span> 가 가역이면 다음이 성립하는 것을 안다.</p>
<p><span class="math display">\[
\boldsymbol{BAu}=\boldsymbol{Bv} \iff \boldsymbol{Au}=\boldsymbol{v}.
\]</span></p>
<p>따라서 <span class="math inline">\(\boldsymbol{Au}=\boldsymbol{v}\)</span> 의 양쪽에 유한번의 기본행연산 <span class="math inline">\(\boldsymbol{E}_1,\ldots,\boldsymbol{E}_N\)</span> 을 수행했을 때도 다음이 성립함을 알 수 있다.</p>
<p><span class="math display">\[
(\boldsymbol{E}_N \cdots \boldsymbol{E}_1)\boldsymbol{Au} = (\boldsymbol{E}_N \cdots \boldsymbol{E}_1) \boldsymbol{v} \iff \boldsymbol{Au} =\boldsymbol{v}
\]</span></p>
<p><br></p>
<div id="exm-infinite_number_of_operations" class="theorem example">
<p><span class="theorem-title"><strong>보기 3.1</strong></span> 벡터공간 <span class="math inline">\(V\)</span> 에서의 유한개의 가역연산자 <span class="math inline">\(T_1,\ldots,\,T_n \in \mathcal{L}(V)\)</span> 와 <span class="math inline">\(S\in \mathcal{L}\)</span> 에 대해</p>
<p><span class="math display">\[
(T_1 \circ \cdots \circ T_n \circ S)(u) = (T_1 \circ \cdots \circ T)(v) \iff S(u)= v
\]</span></p>
<p>이다. 그러나 무한개의 가역연산자의 경우를 생각하자. 항등연산자 <span class="math inline">\(I\)</span> 에 대해 <span class="math inline">\(T_k = \dfrac{1}{k}I\)</span>, <span class="math inline">\(k=1,\,2,\ldots\)</span> 라면 <span class="math inline">\((T_1 \circ \cdots)(u)=0\)</span> 이다. 즉 유한개의 가역연산의 합성은 가역연산이지만 무한개의 가역연산의 합성은 가역연산이라는 것을 보장 할 수 없다.</p>
</div>
<p><br></p>
</section>
</section>
<section id="행-사다리꼴-행렬과-행-간소-사다리꼴-행렬" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="행-사다리꼴-행렬과-행-간소-사다리꼴-행렬"><span class="header-section-number">3.2</span> 행 사다리꼴 행렬과 행 간소 사다리꼴 행렬</h2>
<section id="sec-row_echelon_matrix" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="sec-row_echelon_matrix"><span class="header-section-number">3.2.1</span> 행 사다리꼴 행렬</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-echelon_matrix" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.2 (행 사다리꼴 행렬)</strong></span> 행 사다리꼴 행렬(row echelon form matrix)은 다음의 조건을 만족하는 행렬이다.</p>
<ol type="1">
<li><p>행벡터 가운데 영벡터가 존재할 경우 이 영벡터는 영벡터가 아닌 행벡터의 아래에 위치한다.</p></li>
<li><p>행렬의 행벡터가 영벡터가 아닐 때, 처음으로 나타나는 0 이 아닌 성분을 <strong>선행 성분</strong>이라 한다. 윗 행의 선행 성분은 아래 행 전체의 각각의 선행성분보다 앞서 존재한다.</p></li>
</ol>
</div>
</div>
</div>
</div>
<p><br></p>
<div id="exm-non-echelon_matrix" class="theorem example">
<p><span class="theorem-title"><strong>보기 3.2</strong></span> 아래의 행렬 <span class="math inline">\(\boldsymbol{A}_1,\,\boldsymbol{A}_2\)</span> 는 각각 1, 2 번 조건을 거스르는 행렬이므로 행사다리꼴이 아니다. (선행 성분을 밑줄로 표시하였다.)</p>
<p><span class="math display">\[
\boldsymbol{A}_1 = \begin{bmatrix} \underline{2} &amp; 2 &amp; 0 \\0 &amp; 0 &amp; 0 \\ 0 &amp; \underline{1} &amp; 0\end{bmatrix} , \qquad\boldsymbol{A}_2 = \begin{bmatrix} 0 &amp; 0 &amp; \underline{3} \\ \underline{2} &amp; 0 &amp; 2\end{bmatrix}.
\]</span></p>
</div>
<div id="exm-echelon_matrix" class="theorem example">
<p><span class="theorem-title"><strong>보기 3.3</strong></span> 다음 행렬은 사다리꼴 행렬이다.</p>
<p><span class="math display">\[
\begin{bmatrix} 1 &amp; 0 &amp; 2 &amp; -1 \\ 0 &amp; 2 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 3 &amp; 1\end{bmatrix} ,\qquad \begin{bmatrix}0 &amp; 1 &amp; 2  \\ 0 &amp; 0 &amp; 3  \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0\end{bmatrix}.
\]</span></p>
</div>
<p><br></p>
<p>행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 <span class="math inline">\(i\)</span> 행 <span class="math inline">\(j\)</span> 열 성분을 <span class="math inline">\(A_{ij}\)</span> 라고 쓴다. 이 때 <span class="math inline">\(i\)</span> 를 <em>행 인덱스</em>, <span class="math inline">\(j\)</span> 를 <em>열 인덱스</em>라 하자. 이제 모든 행렬은 기본 행 연산을 통해 행 사다리꼴 행렬로 변형될 수 있다는 것을 보이고자 한다. 우선 <span class="math inline">\(l(\boldsymbol{A}, j)\)</span> 는 <span class="math inline">\(\boldsymbol{A}_{:j}\)</span> 의 선행성분의 열인덱스라고 정의하고 <span class="math inline">\(k\)</span> 행에 대해 다음 두 과정을 생각하자.</p>
<div class="callout callout-style-simple callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
피보팅과 열소거
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>[피보팅]</strong> <span class="math inline">\(m \times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 를 생각하자. <span class="math inline">\(\boldsymbol{A}\)</span> 에서 <span class="math inline">\(l(\boldsymbol{A}, k),\, l(\boldsymbol{A}, k+1), \ldots, l(\boldsymbol{A}, m)\)</span> 중 가장 작은 값(즉 열 인덱스)을 찾아 그 행과 <span class="math inline">\(k\)</span> 행을 교환하는 것을 <span class="math inline">\(k\)</span> 행에 대한 <strong>피보팅 (pivoting)</strong> 이라 한다. 피보팅은 특정 조건에서의 <span class="math inline">\(E^{(1)}\)</span> 기본 행 연산이다. <u> <span class="math inline">\(k\)</span> 행에 대해 피보팅을 하는 것은 <span class="math inline">\(k\)</span> 행 보다 위의 행들은 고려하지 않는다는 것을 유의하라.</u></p>
<p><strong>[열소거]</strong> <span class="math inline">\(k\)</span> 행에 대한 피보팅을 수행한 행렬을 <span class="math inline">\(\boldsymbol{A}'\)</span> 이라 하면 <span class="math inline">\(l(\boldsymbol{A}', j&gt;k) \ge l(\boldsymbol{A}', k)\)</span> 가 된다. <span class="math inline">\(l_k = l(\boldsymbol{A}', k)\)</span> 라고 할 때 기본 행 연산을 통해 <span class="math inline">\(k\)</span> 행 아래의 행들의 <span class="math inline">\(l_k\)</span> 열의 값을 <span class="math inline">\(0\)</span> 으로 만들고자 한다. 즉, <span class="math inline">\(E_3 \left(j, k, - \dfrac{(A')_{j, l_k}}{(A')_{k, l_k}}\right)\)</span> 연산을 <span class="math inline">\(j=k+1, \ldots, m\)</span> 에 대해 수행하면 그 결과로 계산되는 행렬 <span class="math inline">\(\boldsymbol{A}''\)</span> 에서 <span class="math inline">\(k\)</span> 행 아래의 행들의 <span class="math inline">\(l_k\)</span> 번째 열들은 <span class="math inline">\(0\)</span> 이다. 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 <span class="math inline">\(k\)</span> 번째 행에 피보팅을 포함한 위의 연산을 수행하는 것은 기본 행 연산의 반복이므로(정확히는 <span class="math inline">\(E^{(1)}\)</span> 연산과 <span class="math inline">\(E^{(3)}\)</span> 연산의 반복) 가역행렬로 표현 할 수 있다. <u> <span class="math inline">\(k\)</span> 행에 대해 열소거를 하는 것 역시 <span class="math inline">\(k\)</span> 행 보다 위의 행들은 고려하지 않는다는 것을 유의하라.</u></p>
</div>
</div>
<p><br></p>
<p>차례로 <span class="math inline">\(1,\,2,\ldots,\, k-1\)</span> 행에 대해 각각의 행에서의 피보팅과 열소거를 수행한 결과의 행렬을 <span class="math inline">\(\boldsymbol{A}_{k-1}\)</span> 라고 하자. <span class="math inline">\(k\)</span> 행부터 마지막 <span class="math inline">\(m\)</span> 행까지가 모두 영벡터가 아니라면 피보팅이 가능하며, 피보팅 이후에는 <span class="math inline">\(k\)</span> 행이 영벡터가 아니게 된다. 열소거 까지 수행하면 <span class="math inline">\(p&gt;k\)</span> 행에 대해 <span class="math inline">\(l(\boldsymbol{A}_k, k) &lt; l (\boldsymbol{A}_{k}, p)\)</span> 이다. 즉 <span class="math inline">\(1\)</span> 행부터 <span class="math inline">\(j\)</span> 행 까지는 사다리꼴 행렬이다. 이것은 <span class="math inline">\(m-1\)</span> 행까지 피보팅과 열소거를 수행하거나, 나머지 행벡터가 모두 영벡터가 될 때 까지 계속하면 전체 행렬이 사다리꼴 행렬이 된다. 모든 과정은 유한번의 기본 행 연산으로 이루어지므로 우리는 다음을 알 수 있다.</p>
<div id="prp-echolon_matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.2</strong></span> 행렬은 유한번의 기본행연산을 통해 행 사다리꼴 행렬이 될 수 있다.</p>
</div>
<div id="exr-echelon_form1" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 3.1</strong></span> <span class="math inline">\(m \times n\)</span> 인 사다리꼴 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 를 생각하자. <span class="math inline">\(m&gt;n\)</span> 일 때 <span class="math inline">\(n\)</span> 보다 큰 행의 성분은 모두 <span class="math inline">\(0\)</span> 이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 가 사다리꼴 행렬이면 <span class="math inline">\(l(\boldsymbol{A}, i) \ge i\)</span> 인데 <span class="math inline">\(i&gt;n\)</span> 이면 <span class="math inline">\(n\)</span> 보다 큰 열은 존재하지 않는다. 따라서 이 열의 성분은 모두 <span class="math inline">\(0\)</span> 이다.</p>
</div>
<p><br></p>
<p>:::</p>
<p><br></p>
</section>
<section id="sec-reduced_raw_echelon_matrix" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="sec-reduced_raw_echelon_matrix"><span class="header-section-number">3.2.2</span> 행 간소 사다리꼴 행렬</h3>
<p>행 간소 사다리꼴 행렬(row-reduced echelon form matrix)은 행 사다리꼴 행렬의 조건에 더해진다.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-rref" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.3 (행 간소 사다리꼴 행렬)</strong></span> 행렬이 다음의 조건을 만족하면 <strong>행 간소 사다리꼴 행렬</strong> 이라고 한다.</p>
<ol type="1">
<li><p>행벡터 가운데 영벡터가 존재할 경우 이 영벡터는 영벡터가 아닌 행벡터의 아래에 위치한다.</p></li>
<li><p>행렬의 행벡터가 영벡터가 아닐 때, 처음으로 나타나는 성분은 <span class="math inline">\(1\)</span> 이며 이를 <strong>선행 1 성분</strong> 이라 한다. 어떤 행의 선행 1 성분은 아래 모든 행들의 선행 1성분보다 앞서 존재한다.</p></li>
<li><p>선행 1 성분이 존재하는 열은 선행 1 성분을 제외한 모든 성분이 <span class="math inline">\(0\)</span> 이다.</p></li>
</ol>
</div>
</div>
</div>
</div>
<p><br></p>
<p>행 간소 사다리꼴 행렬을 만드는 방법은 사다리꼴 행렬을 만드는 방법과 유사하다. <span class="math inline">\(j=1,\,2,\ldots,\)</span> 행에 대해 다음을 수행한다.</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>[피보팅]</strong> 행 사다리꼴 행렬의 피보팅과 같다.</p>
<p><strong>[선행 1]</strong> 피보팅을 수행한 <span class="math inline">\(j\)</span> 행에 선행 성분의 역수를 곱해서 선행 1 성분으로 만들어준다. 이것은 <span class="math inline">\(E^{(2)}\)</span> 과정이다.</p>
<p><strong>[열소거]</strong> 행 사다리꼴 행렬에서는 <span class="math inline">\(j\)</span> 행보다 아래 행에 대해서만 열 소거 과정을 수행하지만 <u>행 간소 사다리꼴 행렬에 대해서는 <span class="math inline">\(j\)</span> 행을 제외한 나머지 행에 모두에 대해 열소거 과정을 수행한다. </u></p>
</div>
</div>
</div>
<p><br></p>
<p>행 사다리꼴 행렬에 대해서와 같이 1행부터 차례로 수행하며, 마지막 행까지 수행하거나(마지막 행에서는 피보팅을 할 필요가 없다), 어떤 행에 대해 수행했을 때, 그 행의 아래의 행이 모두 영벡터이면 이 과정이 종료된다. 행 사다리꼴 행렬에 비하면 [선행 1] 과정이 추가되었고, [열소거] 과정이 변경되었다. 행 사다리꼴 행렬에서 <span class="math inline">\(k\)</span> 행에 대한 열소거는 <span class="math inline">\(k\)</span> 행보다 아래 행에 대해 수행하지만, 행 간소 사다리꼴 행렬에서는 <span class="math inline">\(k\)</span> 행을 제외한 전체 행에 대해 수행한다. 이 결과로 나오는 행렬은 행 간소 사다리꼴 행렬의 정의를 만족한다.</p>
<p>위의 모든 과정이 행 기본 연산에 의해 수행되기 때문에 우리는 다음을 증명하였다.</p>
<div id="thm-reduced_echelon_matrix" class="theorem">
<p><span class="theorem-title"><strong>정리 3.1</strong></span> 모든 행렬은 유한번의 행 기본 연산에 의해 행 간소 사다리꼴 행렬이 된다.</p>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
행 간소 사다리꼴의 유일성
</div>
</div>
<div class="callout-body-container callout-body">
<p>우리는 어떤 과정에 의해 행렬의 행 간소 사다리꼴을 구할 수 있다는 것을 보았다. 그러나 다른 과정을 통해 구한 행 간소 사다리꼴도 있을 수 있으며, 다른 방법으로 구한 행 간소 사다리꼴이 항상 같은지 아닌지가 문제가 된다. 결론적으로 행렬의 행 간소 사다리꼴은 유일한데 그것은 다음 장의 <a href="ch1_05_matrix.qmd#sec-uniqueness_of_reduced_row_echelon_form">행 간소 사다리꼴의 유일성</a>에서 보일 것이다.</p>
</div>
</div>
<p><br></p>
</section>
</section>
<section id="대칭군" class="level2 page-columns page-full" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="대칭군"><span class="header-section-number">3.3</span> 대칭군</h2>
<p>이제 행렬식에 대해 알아보도록 하자. 행렬식을 도입하는 방법은 여러가지가 있지만 그 가운데 대칭군을 도입하여 정의 한 후 행렬식의 중요한 성질을 하나하나 증명해 나가보도록 한다.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-symmetric_group" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.4 (대칭군과 순열)</strong></span> <span class="math inline">\(n\)</span> 이 1 이상의 자연수일 때 <span class="math inline">\(\{1,\ldots,\,n\} \mapsto \{1, \ldots,\,n\}\)</span> 함수 가운데 전단사 함수 전체의 집합을 <strong>대칭군(symmetric group)</strong> 이라 하고 <span class="math inline">\(S_n\)</span> 이라 표기한다. 대칭군의 원소를 <strong>순열 (permutation)</strong> 이라 한다. </p>
</div>
</div>
</div>
</div>
<div class="no-row-height column-margin column-container"><span class="margin-aside callout-margin-content callout-margin-content-simple">대칭군 (symmetric group) 이라는 이름에서 알 수 있듯이, <span class="math inline">\(S_n\)</span> 은 2부에서 다룰 군(group) 이라는 수학적 구조에 속한다. 하지만 여기서는 특별히 군에 대해 이야기 하지 않을 것이기 때문에 대칭군 이라는 이름을 가지는 집합 정도로 이해하면 되겠다.</span></div><p>예를 들어 <span class="math inline">\(n=3\)</span> 일 때 <span class="math inline">\(\sigma (1) = 1,\, \sigma(2) = 3,\, \sigma(3)=2\)</span> 인 <span class="math inline">\(\sigma\)</span> 는 <span class="math inline">\(S_3\)</span> 의 원소이지만 <span class="math inline">\(\tau(1)=2\)</span>, <span class="math inline">\(\tau(2)=2\)</span>, <span class="math inline">\(\tau(3)=1\)</span> 은 전단사 함수가 아니기 때문에 <span class="math inline">\(S_3\)</span> 의 원소가 아니다. 또한 <span class="math inline">\(S_n\)</span> 은 함수의 집합이므로 그 원소들에 대한 함수의 합성과 역함수를 생각 할 수 있다. (늘 그렇듯이) <span class="math inline">\(\sigma\in S_n\)</span> 에 대한 역함수는 <span class="math inline">\(\sigma^{-1}\)</span> 로 표기하며, <span class="math inline">\(\sigma_1,\,\sigma_2\in S_n\)</span> 의 합성은 <span class="math inline">\(\sigma_1 \circ \sigma_2\)</span> 로 표기한다. 항등순열 <span class="math inline">\(i_d \in S_n\)</span> 은 <span class="math inline">\(i_d(i)=i\)</span> <span class="math inline">\((i=1,\ldots, n)\)</span> 인 순열이다.</p>
<p><br></p>
<section id="순열의-표기" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="순열의-표기"><span class="header-section-number">3.3.1</span> 순열의 표기</h3>
<section id="기본적인-표기법" class="level4">
<h4 class="anchored" data-anchor-id="기본적인-표기법">기본적인 표기법</h4>
<p><span class="math inline">\(\sigma \in S_n\)</span> 일 때 <span class="math inline">\(1,\,2,\,\ldots,\,n\)</span> 과 <span class="math inline">\(\sigma(1),\,\sigma(2),\ldots,\, \sigma(n)\)</span> 을 두줄로 아래와 같이 표기할 수 있다.</p>
<p><span class="math display">\[
\sigma = \begin{pmatrix} 1 &amp; 2 &amp; \cdots &amp; n \\ \sigma(1) &amp; \sigma(2) &amp; \cdots &amp; \sigma (n)\end{pmatrix}
\]</span></p>
<p>예를 들어 <span class="math inline">\(\sigma = \begin{pmatrix} 1 &amp; 2 &amp; 3 &amp; 4 \\ 2 &amp; 3 &amp; 1 &amp; 4\end{pmatrix}\)</span> 는 <span class="math inline">\(\sigma(1)=2,\, \sigma (2)=3,\,\sigma(3)=1,\,\sigma(4)=4\)</span> 이다.</p>
<p><br></p>
</section>
<section id="순환-표기법-cyclic-notation" class="level4">
<h4 class="anchored" data-anchor-id="순환-표기법-cyclic-notation">순환 표기법 (cyclic notation)</h4>
<p><span class="math inline">\(\sigma = (1,\,3,\,2) \in S_5\)</span> 의 경우 <span class="math inline">\(\sigma(1) = 3\)</span>, <span class="math inline">\(\sigma(3)=2\)</span>, <span class="math inline">\(\sigma(2)=1\)</span>, <span class="math inline">\(\sigma (4)=4\)</span>, <span class="math inline">\(\sigma(5)=5\)</span> 가 된다. 즉, <span class="math inline">\(\sigma = (i_1,\,i_2,\ldots,\,i_m) \in S_n,\, m \le n\)</span> 의 경우</p>
<p><span class="math display">\[
\left\{ \begin{array}{ll}\sigma (i_k) = i_{k+1}, \qquad &amp; k=1,\ldots,\,m-1 \\ \sigma (i_m) = i_1, \\ \sigma(j) = j &amp; j \not\in \{i_1,\ldots,\,i_m\}\end{array}\right.
\]</span></p>
<p>인 순열이다. 즉 <span class="math inline">\(\sigma(j)=j\)</span> 인 경우는 굳이 순환표기법에 넣지 않는다. 일반적인 표기법의 <span class="math inline">\(\sigma = \begin{pmatrix} 1 &amp; 2 &amp; 3 &amp; 4 \\ 2 &amp; 3 &amp; 1 &amp; 4\end{pmatrix}\)</span> 를 순환표기법으로 표현하면, <span class="math inline">\((1, 2, 3)\)</span> 이 된다. 또한 <span class="math inline">\(\sigma = (1, 4, 2, 3)\in S_4\)</span> 을 일반표기법으로 표현하면</p>
<p><span class="math display">\[
\sigma = \begin{pmatrix} 1 &amp; 2 &amp; 3 &amp; 4 \\ 4 &amp; 3 &amp; 1 &amp;2\end{pmatrix}
\]</span> 가 된다.</p>
<p><span class="math inline">\((1, 3, 2)(4, 2)\)</span> 처럼 순열을 곱하는 것처럼 쓰면 합성함수처럼 생각한다. <span class="math inline">\(\sigma_1 = (1, 3, 2),\, \sigma_2=(4, 2)\)</span> 에 대해 <span class="math inline">\(\sigma = \sigma_1 \circ \sigma_2 =  (1, 3, 2)(4, 2)\)</span> 이다. 즉 <span class="math inline">\(\sigma(2) = \sigma_1(\sigma_2(2))=\sigma_1(4) = 4\)</span> 이다.</p>
<p><br></p>
</section>
<section id="k-cycle-과-호환" class="level4">
<h4 class="anchored" data-anchor-id="k-cycle-과-호환"><span class="math inline">\(k\)</span>-cycle 과 호환</h4>
<p>이제</p>
<p><span class="math display">\[
\sigma = \begin{pmatrix} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5  \\ 2 &amp; 3 &amp; 1 &amp; 5 &amp; 4\end{pmatrix}
\]</span></p>
<p>를 보자. <span class="math inline">\(1,\,2,\,3\)</span> 은 <span class="math inline">\(1,\,2,\,3\)</span> 내에서 <span class="math inline">\(4,\,5\)</span> 는 <span class="math inline">\(4,\,5\)</span> 내에서 순환됨을 알 수 있다. 이것은 합성순열처럼 <span class="math inline">\((1, 2, 3) (4, 5)\)</span> 로 쓸 수 있다. 하나의 <span class="math inline">\((\cdots)\)</span> 안에 <span class="math inline">\(k\)</span> 개의 숫자가 있을 때 <span class="math inline">\(k\)</span>-<strong>cycle</strong> 이라고 하며 각각의 <span class="math inline">\(k\)</span>-cycle 들을 cycle 이라고 한다. <span class="math inline">\((1, 3, 2, 4)\)</span> 는 4-cycle 이다. <span class="math inline">\(k=2\)</span> 일 경우는 특별히 <strong>호환 (transposition)</strong> 이라 한다.</p>
<p><br></p>
<div id="prp-basic_properties_of_permutation" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.3</strong></span> <span class="math inline">\(S_n\)</span> 에 대해 다음이 성립한다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(\sigma \in S_n \implies \sigma^{-1} \in S_n\)</span>,</p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\(\sigma,\, \tau\in S_n \implies \sigma \circ \tau \in S_n\)</span>,</p>
<p>  (<span class="math inline">\(3\)</span>) <span class="math inline">\(\sigma, \tau, \theta \in S_n \implies (\sigma \circ \tau)\circ \theta = \sigma \circ (\tau \circ \theta)\)</span>,</p>
<p>  (<span class="math inline">\(4\)</span>) <span class="math inline">\(\{\sigma^{-1}: \sigma\in S_n\}=S_n\)</span>,</p>
<p>  (<span class="math inline">\(5\)</span>) <span class="math inline">\(\tau \in S_n \implies \{\tau \circ \sigma : \sigma \in S_n\} = S_n\)</span></p>
<p>  (<span class="math inline">\(6\)</span>) <span class="math inline">\(\sigma\)</span> 가 호환이면 <span class="math inline">\(\sigma^2 = i_d\)</span> 이다.</p>
<p>  (<span class="math inline">\(7\)</span>) <span class="math inline">\(\sigma\)</span> 가 <span class="math inline">\(k\)</span>-cycle 이면 <span class="math inline">\(\sigma^k = i_d\)</span> 이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(1\)</span>), (<span class="math inline">\(2\)</span>), (<span class="math inline">\(3\)</span>) 의 증명은 쉬우므로 생략한다.</p>
<p>(<span class="math inline">\(4\)</span>) <span class="math inline">\(\sigma\in S_n\)</span> 이면 <span class="math inline">\(\sigma\)</span> 는 전단사 함수이므로 <span class="math inline">\(\sigma^{-1}\)</span> 이 존재하며 <span class="math inline">\(S_n\)</span> 의 정의에 의해 <span class="math inline">\(\sigma^{-1}\in S_n\)</span> 이다. <span class="math inline">\(\sigma = (\sigma^{-1})^{-1}\)</span> 이므로, 즉 모든 <span class="math inline">\(\sigma \in S_n\)</span> 은 어떤 <span class="math inline">\(\tau\in S_n\)</span> 에 대해 <span class="math inline">\(\sigma=\tau^{-1}\)</span> 이므로 증명된다.</p>
<p>(<span class="math inline">\(5\)</span>) <span class="math inline">\(\tau,\, \sigma_1,\, \sigma_2\in S_n\)</span> 에 대해 <span class="math display">\[
\tau \circ \sigma_1 = \tau \circ \sigma_2 \implies \tau^{-1} \circ \tau \circ \sigma_1 = \tau^{-1} \circ \tau \circ \sigma_2 \implies \sigma_1= \sigma_2
\]</span></p>
<p>이다. 즉 <span class="math inline">\(\sigma_1 \ne \sigma_2 \implies \tau \circ \sigma_1 \ne \tau \circ \sigma_2\)</span> 이다. <span class="math inline">\(\{\tau \circ \sigma : \sigma \in S_n\} \subset S_n\)</span> 이며 두 집합의 원소의 갯수가 같으므로 두 집합은 같다.</p>
<p>(<span class="math inline">\(6\)</span>) <span class="math inline">\(\sigma =(i,\,j)\)</span> 라 하자 <span class="math inline">\((\sigma\circ\sigma) (i)= \sigma(j) = i\)</span> 이며 역시 <span class="math inline">\((\sigma\circ\sigma) (j)= \sigma(i) = j\)</span> 이다.</p>
<p>(<span class="math inline">\(7\)</span>) <span class="math inline">\(\sigma = (i_1,\ldots,\,i_k)\)</span> 라 하자. <span class="math inline">\(\sigma(i_1)=(i_2),\, \sigma^2(i_1)=i_3\)</span> 이므로 <span class="math inline">\(\sigma^k(i_1) = i_1\)</span> 이다. <span class="math inline">\(\sigma = (i_2,\ldots,\, i_k,\,i_1)\)</span> 이므로 <span class="math inline">\(\sigma^k (i_2)=i_2\)</span> 이다. 같은 방법으로 <span class="math inline">\(k\)</span>-cycle <span class="math inline">\(\sigma\)</span> 에 대해 <span class="math inline">\(\sigma^k=i\)</span> 임을 보일 수 있다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
</section>
<section id="순열의-분해" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="순열의-분해"><span class="header-section-number">3.3.2</span> 순열의 분해</h3>
<p>두 cycle <span class="math inline">\(\sigma_1,\, \sigma_2 \in S_n\)</span> 에 대해 <span class="math inline">\(\sigma_1,\,\sigma_2\)</span> 에 겹치는 정수가 없을 때 두 cycle 을 <strong>disjoint</strong> 하다고 한다. 모든 순열은 disjoint 한 cycle 의 합성으로 표현 할 수 있다는 것은 쉽게 알 수 있다. 또한 <span class="math inline">\(\sigma,\, \tau\)</span> 가 disjoint 한 두 cycle 일 때 <span class="math inline">\(\sigma \circ \tau = \tau \circ \sigma\)</span> 임을 쉽게 예상 할 수 있다. 그러나 서로 disjoint 하지 않은 두 cycle 에 대해서는 교환법칙이 성립하지 않을 수 있다.</p>
<div id="exm-non_disjoint_cycle_product" class="theorem example">
<p><span class="theorem-title"><strong>보기 3.4</strong></span> <span class="math inline">\(\sigma = (1, 3, 2),\, \tau = (2, 4)\)</span> 라 하자. <span class="math inline">\(2\)</span> 가 <span class="math inline">\(\sigma,\,\tau\)</span> 에 모두 포함되므로 <span class="math inline">\(\sigma\)</span> 와 <span class="math inline">\(\tau\)</span> 는 disjoint 하지 않다. <span class="math inline">\((\sigma \circ\tau) (2) = 4\)</span> 이지만 <span class="math inline">\((\tau \circ \sigma)(2) = 1\)</span> 이다. 즉 이 경우에는 <span class="math inline">\(\sigma \circ \tau \ne \tau \circ \sigma\)</span> 이다.</p>
</div>
<p>순열 <span class="math inline">\(\sigma \in S_n\)</span> 은 disjoint cycles 의 곱으로 표현 할 수 있다. 그리고 이 곱은 교환법칙이 성립하므로 곱의 순서와는 무관하다. 순서를 고려하지 않을 때, 순열을 disjoint cycles 로 나누는 것을 <strong>순열의 분해</strong>라고 한다. 이제 순열의 분해에 대해 몇가지를 증명하자.</p>
<p><br></p>
<div id="prp-uniqueness_discomposition_of_permutation" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.4</strong></span> 순열의 분해는 유일하다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\sigma \in S_n\)</span> 이 <span class="math inline">\(\sigma_1 \cdots \sigma_m\)</span> 과 <span class="math inline">\(\tau_1\cdots \tau_n\)</span> 으로 분해된다고 하자. 즉 <span class="math inline">\(\sigma_1,\ldots,\,\sigma_m\)</span> 은 서로 disjoint 하고 <span class="math inline">\(\tau_1,\ldots,\,\tau_n\)</span> 도 서로 disjoint 하다. <span class="math inline">\(i \in \sigma_1\)</span> 이면 <span class="math inline">\(i\in \tau_k\)</span> 가 존재해야 한다. 그리고 <span class="math inline">\(\sigma(i)\in \sigma_1,\, \sigma(i)\in \tau_k\)</span> 이어야 하며 (이 논리를 계속 따라가면), 따라서 <span class="math inline">\(\sigma_1 = \tau_k\)</span> 이어야 한다. 즉 모든 <span class="math inline">\(\sigma_j,\,i=1,\ldots,\,m\)</span> 에 대해 어떤 <span class="math inline">\(\tau_p,\, p=1,\ldots,\,m\)</span> 가 존재하여 <span class="math inline">\(\sigma_j = \tau_p\)</span> 이어야 한다. 역으로 모든 <span class="math inline">\(\tau_p\)</span> 에 대해 어떤 <span class="math inline">\(\sigma_j\)</span> 가 존재하여 <span class="math inline">\(\tau_p = \sigma_j\)</span> 이어야 한다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div id="prp-decomposition_to_transposition" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.5</strong></span> 모든 순열은 호환(transposition) 의 합성으로 표현 할 수 있다. 이 호환의 합성은 유일하지 않다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>우리는 앞서 모든 순열이 disjoint cycles 의 합성으로 분해된다는 것을 보았다. 따라서 임의의 <span class="math inline">\(k\)</span>-cycle 이 호환의 합성으로 표현될 수 있다는 것을 아래와 같이 보이면 된다. <span class="math display">\[
\begin{aligned}
(i_1,\ldots,\,i_k) &amp;= (i_1,\, i_2)(i_2,\,i_3)\cdots (i_{k-2},\, i_{k-1})(i_{k-1},\, i_k) \\
&amp;= (i_1,\, i_k) (i_1,\, i_{k-1}) \cdots (i_1,\,i_3)(i_1,\,i_2)
\end{aligned}
\]</span></p>
<p>위 식에서 하나의 <span class="math inline">\(k\)</span>-cycle 을 두 종류의 호환의 합성으로 보였다. 즉 이 호환의 합성은 유일하지 않다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
<section id="순열에-대한-textsgn-함수" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="순열에-대한-textsgn-함수"><span class="header-section-number">3.3.3</span> 순열에 대한 <span class="math inline">\(\text{sgn}\)</span> 함수</h3>
<p>우리는 순열이 호환의 합성으로 표현 가능하다는 것을 알았다. 그러나 이 호환의 합성은 유일하지도 않고, 호환의 갯수도 유일하지 않다.</p>
<p><span class="math display">\[
\begin{aligned}
\sigma ={\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\3 &amp; 4 &amp; 5 &amp; 2 &amp; 1\end{pmatrix}} = (1,\,3,\,5)(2,\,4) &amp;= (1,\,3) (3,\,5) (2,\,4)\\
&amp;= (1,\, 5)(3,\, 4)(2,\, 4)(1,\, 2)(2,\, 3).
\end{aligned}
\]</span></p>
<p>그러나 순열을 호환의 합성으로 표현했을 때 호환의 갯수가 짝수개인지 홀수개인지는 불변이며 이것을 증명하고자 한다.</p>
<div id="lem-sgn_of_permutaion" class="theorem lemma">
<p><span class="theorem-title"><strong>보조정리 3.1</strong></span> 호환 <span class="math inline">\(\tau_1,\ldots,\,\tau_m \in S_n\)</span> 이 <span class="math inline">\(\tau_m \cdots \tau_1=i_d\)</span> 이면 <span class="math inline">\(m\)</span> 은 항상 짝수이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\sigma =\tau_m \cdots \tau_1\)</span> 이라 하자. <span class="math inline">\(\tau_1,\ldots,\,\tau_m\)</span> 가운데 나타나는 자연수중 하나인 <span class="math inline">\(p\)</span> 를 선택하자 <span class="math inline">\(p\)</span> 가 나오는 <span class="math inline">\(\tau\)</span> 의 가장 작은 인덱스 <span class="math inline">\(j\)</span> 는 <span class="math inline">\(m\)</span> 이 아닌데 만약 <span class="math inline">\(p\)</span> 가 <span class="math inline">\(m\)</span> 에만 나온다면 <span class="math inline">\(\sigma (p) \ne p\)</span> 이기 때문이다. 즉 <span class="math inline">\(j\le m-1\)</span> 이다. 이 때 가능한 <span class="math inline">\(\tau_{j+1}\circ \tau_j\)</span> 는 아래의 네가지 형태중 하나이다.</p>
<p><span class="math display">\[
\begin{aligned}
(p, x) \circ (p, x) &amp;= i_d,\\
(p, y) \circ (p, x) &amp; = (p, x) \circ (x, y), \\
(x, y) \circ (p, x) &amp; = (p, y) \circ (x, y), \\
(y, z) \circ (p, x) &amp;= (p, x) \circ (y, z).
\end{aligned}
\]</span></p>
<p>즉 전체 <span class="math inline">\(\sigma\)</span> 의 입장에서 보면, <span class="math inline">\(\tau_{j+1}\circ \tau_j\)</span> 에 의해 <span class="math inline">\(p\)</span> 가 없어지면서 <span class="math inline">\(2\)</span> 개의 호한이 사라지거나, 호환의 갯수를 유지하면서 한칸 왼쪽으로 가는 순열과 같아진다. 계속 왼쪽으로 보내는 것을 반복하면 언젠가는 가장 왼쪽의 <span class="math inline">\(\tau_m\)</span> 위치에 오게되는데 이렇게 되면 앞서의 이유로 <span class="math inline">\(\sigma \ne i_d\)</span> 이다. 즉 언젠가는 <span class="math inline">\(2\)</span> 개의 호환이 사라져야 한다. <span class="math inline">\(\tau_1,\ldots,\,\tau_m\)</span> 에 나타나는 모든 자연수가 사라져야 하므로 <span class="math inline">\(\sigma = i_d\)</span> 가 되려면 <span class="math inline">\(m\)</span> 은 짝수여야 한다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div id="prp-permutation_even_odd" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.6</strong></span> 순열을 분해했을 때의 호환의 갯수의 짝수/홀수 여부는 순열을 어떻게 분해하더라도 불변이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\sigma\in S_n\)</span> 이 <span class="math inline">\(\sigma = \tau_m\cdots \tau_1 = \tau'_n \cdots \tau'_1\)</span> 이라 하자. 우리가 보이고 싶은 것은 <span class="math inline">\(n\)</span> 이 짝수이면 <span class="math inline">\(m\)</span> 도 짝수, <span class="math inline">\(n\)</span> 이 홀수이면 <span class="math inline">\(m\)</span> 도 홀수라는 것이다. 이것은 <span class="math inline">\(m+n\)</span> 이 항상 짝수라는 것과 동치이다. 여기서 <span class="math inline">\(\tau_i,\,\tau'_j\)</span> 는 모두 호환이며 호환의 역원은 자기 자신이므로,</p>
<p><span class="math display">\[
\tau'_1 \cdots \tau'_n \tau_m \cdots \tau_1 = i_d
\]</span></p>
<p>이다. 즉 이 문제는 호환 <span class="math inline">\(\tau_1,\ldots,\,\tau_N\)</span> 에 대해 <span class="math inline">\(\tau_1 \cdots \tau_N = I\)</span> 일 때 <span class="math inline">\(N\)</span> 은 항상 짝수임을 보이는 문제와 같은데 이것은 <a href="#lem-sgn_of_permutaion" class="quarto-xref">보조정리&nbsp;<span>3.1</span></a> 에서 보였다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>따라서 우리는 어떤 순열 <span class="math inline">\(\sigma\)</span> 가 짝수개의 호환의 합성인지, 홀수개의 호환의 합성인지는 결정되어 있으며, 각각 <strong>짝순열 (even permutaion)</strong>, <strong>홀순열 (odd permutation)</strong> 이라 한다. 이제 순열에 대한 <span class="math inline">\(\text{sgn}\)</span> 함수를 정의 할 수 있다.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-sign_of_permutation" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.5 (<span class="math inline">\(\text{sgn}(\sigma)\)</span>)</strong></span> <span class="math inline">\(\sigma \in S_n\)</span> 일 때 <span class="math inline">\(\text{sgn}(\sigma)\)</span> 함수를 다음과 같이 정의한다.</p>
<p><span class="math display">\[
\text{sgn}(\sigma) = \left\{\begin{array}{ll} +1, \qquad &amp;\sigma \text{ 는 짝수개의 호환의 합성 } \\ -1, &amp;\sigma \text{ 는 홀수개의 호환의 합성 }  \end{array} \right.
\]</span></p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><span class="math inline">\(\text{sgn}\)</span> 함수에 대한 몇가지 성질을 보자.</p>
<div id="prp-sgn_of_permutation" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.7</strong></span> <span class="math inline">\(\sigma,\, \tau \in S_n\)</span> 에 대해 다음이 성립한다.</p>
<ol type="1">
<li><span class="math inline">\(\text{sgn}(\tau \circ \sigma) = \text{sgn}(\tau) \, \text{sgn}(\sigma)\)</span>,</li>
<li><span class="math inline">\(\text{sgn}(\sigma) = \text{sgn}(\tau)\,\text{sgn}(\sigma)\,\text{sgn}(\tau)\)</span>.</li>
</ol>
</div>
<p>증명은 쉬우므로 생략한다.</p>
<p><br></p>
</section>
</section>
<section id="sec-determinant_definition_using_symmetric_group" class="level2 page-columns page-full" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="sec-determinant_definition_using_symmetric_group"><span class="header-section-number">3.4</span> 대칭군을 이용한 행렬식</h2>
<p>행렬식을 도입하는 방법은 몇가지가 있다. 여기서는 우선 대칭군을 이용하여 행렬식을 도입하기로 한다.</p>
<section id="행렬식의-정의" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="행렬식의-정의"><span class="header-section-number">3.4.1</span> 행렬식의 정의</h3>
<p>행렬에 대한 행렬식을 정의하기 전에 행벡터에 대한 함수 하나를 정의한다.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-determinant_1" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.6</strong></span> <span class="math inline">\(\{\boldsymbol{a}_i : i=1,\ldots,\,n\} \subset  V=\mathcal{M}_{1 \times n}(\mathbb{F})\)</span> 일 때 <span class="math inline">\(\boldsymbol{a}_i\)</span> 의 <span class="math inline">\(j\)</span> 번째 성분을 <span class="math inline">\((\boldsymbol{a}_i)_j\)</span> 혹은 <span class="math inline">\(a_{ij}\)</span> 라 하자. 이 때 <span class="math inline">\(\det : V^n \to \mathbb{F}\)</span> 를 다음과 같이 정의한다.</p>
<p><span class="math display">\[
\det (\boldsymbol{a}_1,\ldots,\,\boldsymbol{a}_n) = \sum_{\sigma\in S_n} \text{sgn}(\sigma)\left( \prod_{i=1}^n a_{i\sigma(i)}\right)
\]</span></p>
</div>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="det-함수의-기본적인-성질" class="level3 page-columns page-full" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="det-함수의-기본적인-성질"><span class="header-section-number">3.4.2</span> <span class="math inline">\(\det\)</span> 함수의 기본적인 성질</h3>
<div id="exr-determinant_of_identity" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 3.2</strong></span> 단위 벡터 <span class="math inline">\(\hat{\boldsymbol{e}}_i \in \mathcal{M}_{1 \times n}(\mathbb{F}),\, i=1,\ldots,\,n\)</span> 를</p>
<p><span class="math display">\[
(\hat{\boldsymbol{e}}_i)_j = \delta_{ij}
\]</span></p>
<p>로 정의하자. 즉 <span class="math inline">\(\boldsymbol{e}_i\)</span> 는 <span class="math inline">\(i\)</span> 번째 성분이 <span class="math inline">\(1\)</span>, 나머지 성분이 모두 <span class="math inline">\(0\)</span> 인 <span class="math inline">\(1 \times n\)</span> 행렬이다. 그렇다면, <span class="math display">\[
\det (\hat{\boldsymbol{e}}_1,\ldots,\,\hat{\boldsymbol{e}}_n) = 1
\]</span></p>
<p>임을 보여라.</p>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span><span class="math inline">\(e_{ij} = (\hat{\boldsymbol{e}}_i)_j = \delta_{ij}\)</span> 라 하면, <span class="math display">\[
\sum_{\sigma\in S_n} \text{sgn}(\sigma) \prod_{i=1}^n e_{i\sigma(i)} = \sum_{\sigma\in S_n} \text{sgn}(\sigma) \prod_{i=1}^n \delta_{i\sigma(i)} = \text{sgn}(i_d)=1
\;\square
\]</span></p>
</div>
<p><br></p>
<div id="exr-determinant_change_of_order" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 3.3</strong></span> 정해진 <span class="math inline">\(\tau \in S_n\)</span> 에 대해</p>
<p><span class="math display">\[
\det (\boldsymbol{a}_{\tau(1)},\ldots,\boldsymbol{a}_{\tau(n)}) = \text{sgn}(\tau)\,\det (\boldsymbol{a}_1,\ldots,\,\boldsymbol{a}_n)
\]</span></p>
<p>임을 보여라.</p>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span><span class="math inline">\(\text{sgn}(\tau \circ \tau^{-1})=1\)</span> 이므로 임의의 <span class="math inline">\(\sigma\in S_n\)</span> 에 대해 <span class="math inline">\(\text{sgn}(\sigma) = \text{sgn}(\tau) \,\text{sgn}(\sigma \circ \tau^{-1})\)</span> 임을 이용한다. 우선 정의에 의해 <span class="math display">\[
\begin{aligned}
\det (\boldsymbol{a}_{\tau(1)},\ldots,\boldsymbol{a}_{\tau(n)}) &amp;= \sum_{\sigma\in S_n} \text{sgn}(\sigma) \prod_{i=1}^n a_{\tau(i),\sigma(i)} \\
\end{aligned}
\]</span></p>
<p>이다. <span class="math inline">\(\tau(i) = j\)</span> 라 하면 <span class="math inline">\(\sigma(i) = \sigma \circ \tau^{-1}(j)\)</span> 이다. <span class="math inline">\(\tau\)</span> 가 전단사 함수이므로 <span class="math display">\[
\prod_{i=1}^n a_{\tau (i),\sigma(i)} = \prod_{j=1}^n a_{j,(\sigma \circ \tau^{-1})(j)}
\]</span> 이다. 즉, <span class="math display">\[
\begin{aligned}
\det (\boldsymbol{a}_{\tau(1)},\ldots,\boldsymbol{a}_{\tau(n)}) &amp;= \sum_{\sigma\in S_n} \text{sgn}(\sigma)\prod_{i=1}^n a_{i, (\sigma \circ \tau^{-1})(i)} \\
&amp;= \text{sgn}(\tau) \sum_{\sigma\in S_n} \text{sgn}(\sigma \circ \tau^{-1}) \prod_{i=1}^n a_{i,\, (\sigma \circ \tau^{-1})(i)}
\end{aligned}
\]</span></p>
<p>이다. <a href="#prp-basic_properties_of_permutation" class="quarto-xref">명제&nbsp;<span>3.3</span></a> 에 의해 <span class="math inline">\(\{ \sigma \circ \tau^{-1} : \sigma \in S_n\} = S_n\)</span> 이므로,</p>
<p><span class="math display">\[
\det (\boldsymbol{a}_{\tau(1)},\ldots,\boldsymbol{a}_{\tau(n)}) =\text{sgn}(\tau) \,\det (\boldsymbol{a}_1,\ldots,\boldsymbol{a}_n)
\]</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div id="prp-altermating_form_of_determinant" class="theorem proposition page-columns page-full">
<div class="page-columns page-full"><p><span class="theorem-title"><strong>명제 3.8</strong></span> <span class="math inline">\(i\ne j\)</span> 에 대해 <span class="math inline">\(i\)</span> 번째 벡터와 <span class="math inline">\(j\)</span> 번째 벡터를 바꿨을 때, 다음이 성립한다.  <span class="math display">\[
\det(\boldsymbol{a}_1,\ldots,\boldsymbol{a}_i,\ldots,\,\boldsymbol{a}_j,\ldots,\boldsymbol{a}_n) = - \det(\boldsymbol{a}_1,\ldots,\boldsymbol{a}_j,\ldots,\,\boldsymbol{a}_i,\ldots,\boldsymbol{a}_n)
\]</span></p><div class="no-row-height column-margin column-container"><span class="margin-aside"><a href="#prp-altermating_form_of_determinant" class="quarto-xref">명제&nbsp;<span>3.8</span></a> 의 성질을 만족하는 <span class="math inline">\(V^n \mapsto \mathbb{F}\)</span> 함수를 <a href="../../src/part3/bilinear_form.html#def-alternating_form">alternating bilinear form</a> 이라고 한다.</span></div></div>
<p>또한 <span class="math inline">\(\boldsymbol{a}_i = \boldsymbol{a}_j\)</span> 이면, 행렬식이 <span class="math inline">\(0\)</span> 이다. 즉,</p>
<p><span class="math display">\[
\det (\ldots,\boldsymbol{a},\ldots,\boldsymbol{a},\ldots) =  0
\]</span></p>
<p>이 성립한다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>호환 <span class="math inline">\(\tau = (i,\,j)\)</span> 를 생각하면 <span class="math inline">\(\text{sgn}(\tau) =  -1\)</span> 이므로 첫번째 식을 증명한다. <span class="math inline">\(\boldsymbol{a}_i = \boldsymbol{a}_j\)</span> 이면 <span class="math inline">\(\det (\ldots,\boldsymbol{a},\ldots,\,\boldsymbol{a},\ldots) = - \det (\ldots,\boldsymbol{a},\ldots,\,\boldsymbol{a},\ldots)\)</span> 이므로 행렬식이 <span class="math inline">\(0\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div id="prp-bilinearity_of_determinant" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.9</strong></span> <span class="math inline">\(\boldsymbol{a}_1,\ldots,\,\boldsymbol{a}_n\in \mathcal{M}_{1\times n}(\mathbb{F})\)</span>, <span class="math inline">\(c \in \mathbb{F}\)</span> 와 임의의 <span class="math inline">\(1\le j \le n\)</span> 에서의 <span class="math inline">\(\boldsymbol{a}'_j \in \mathbb{F}^{1\times n}\)</span> 에 대해</p>
<p><span class="math display">\[
\begin{aligned}
\det (\boldsymbol{a}_1,\ldots,\boldsymbol{a}_j + &amp;c\boldsymbol{a}'_j, \ldots,\boldsymbol{a}_n) =\\
&amp; \det (\boldsymbol{a}_1,\ldots,\boldsymbol{a}_j,\ldots,\boldsymbol{a}_n) + c \det (\boldsymbol{a}_1,\ldots,\boldsymbol{a}'_j,\ldots,\boldsymbol{a}_n)
\end{aligned}
\]</span></p>
<p>이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math display">\[
\begin{aligned}
\det (\boldsymbol{a}_1,\ldots,&amp;\boldsymbol{a}_j + c \boldsymbol{a}'_j, \ldots,\,\boldsymbol{a}_n) \\
&amp;= \sum_{\sigma\in S_n} \text{sgn}(\sigma) a_{1\sigma(1)} \cdots [a_{j\sigma(j)}+ c a'_{j \sigma(j)}] \cdots a_{n\sigma(n)} \\
&amp;= \sum_{\sigma\in S_n} \text{sgn}(\sigma) a_{1\sigma(1)} \cdots a_{j\sigma(j)}\cdots a_{n \sigma(n)}   \\
&amp;\qquad \qquad + c \sum_{\sigma\in S_n} \text{sgn}(\sigma) a_{1\sigma(1)} \cdots a'_{j\sigma(j)}\cdots a_{n \sigma(n)}  \\
&amp;= \det(\boldsymbol{a}_1,\ldots,\boldsymbol{a}_j, \ldots,\boldsymbol{a}_n) + c \det (\boldsymbol{a}_1,\ldots,\boldsymbol{a}'_j, \ldots, \boldsymbol{a}_n) \qquad \square
\end{aligned}
\]</span></p>
</div>
<p><br></p>
<p>이를 이용하면 다음을 쉽게 보일 수 있다.</p>
<div id="prp-determinant_scala_multiple" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.10</strong></span> <span class="math display">\[
\det (c_1 \boldsymbol{a}_1, \ldots, c_n \boldsymbol{a}_n) = c_1 \cdots c_n \det (\boldsymbol{a}_1,\ldots,\boldsymbol{a}_n)
\]</span></p>
</div>
<p><br></p>
<div id="prp-linear_dependency_and_determinant" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.11 (선형종속과 행렬식)</strong></span> <span class="math inline">\(\boldsymbol{a}_1,\ldots,\boldsymbol{a}_n\in \mathcal{M}_{1\times n}(\mathbb{F})\)</span> 가 선형종속이면 <span class="math inline">\(\det(\boldsymbol{a}_1,\ldots,\,\boldsymbol{a}_n)=0\)</span> 이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>마지막 <span class="math inline">\(\boldsymbol{a}_n\)</span> 이 다른 벡터들의 선형결합이라고 하자. <span class="math inline">\(\boldsymbol{a}_n = \sum_i^{n-1} c_i \boldsymbol{a}_i\)</span> 라면, <a href="#prp-altermating_form_of_determinant" class="quarto-xref">명제&nbsp;<span>3.8</span></a>, <a href="#prp-bilinearity_of_determinant" class="quarto-xref">명제&nbsp;<span>3.9</span></a> 를 이용하여 다음을 보일 수 있다.</p>
<p><span class="math display">\[
\begin{aligned}
\det (\boldsymbol{a}_1,\ldots,\,\boldsymbol{a}_n) &amp;= \det \left(\boldsymbol{a}_1,\ldots,\,\boldsymbol{a}_{n-1},\, \sum_{i=1}^{n-1}c_i \boldsymbol{a}_i\right) \\
&amp;= \det \left(\boldsymbol{a}_1,\ldots,\,\boldsymbol{a}_{n-1},\, c_1 \boldsymbol{a}_1\right) + \det \left(\boldsymbol{a}_1,\ldots,\,\boldsymbol{a}_{n-1},\, \sum_{i=2}^{n-1}c_i \boldsymbol{a}_i\right) \\
&amp;= \qquad \vdots \\
&amp; = \sum_{i=1}^{n-1} c_i \det(\boldsymbol{a}_1,\ldots,\,\boldsymbol{a}_{n-1},\, \boldsymbol{a}_i) = 0.
\end{aligned}
\]</span></p>
<p>선형종속인 벡터가 마지막 벡터가 아닌 경우에는 <a href="#prp-altermating_form_of_determinant" class="quarto-xref">명제&nbsp;<span>3.8</span></a> 를 이용하여 마지막 벡터와 위치를 바꿀 수 있다. 그 경우 행렬식은 원래의 행렬식에 <span class="math inline">\(-1\)</span> 을 곱한 값이므로 명제가 성립한다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
<section id="sec-determinant" class="level3 page-columns page-full" data-number="3.4.3">
<h3 data-number="3.4.3" class="anchored" data-anchor-id="sec-determinant"><span class="header-section-number">3.4.3</span> 행렬식</h3>
<p>이제 <span class="math inline">\(\mathcal{M}_{1 \times n}(\mathbb{F})\)</span> 에 속하는 행벡터 <span class="math inline">\(n\)</span> 개에 대한 함수를 <span class="math inline">\(\mathcal{M}_{n \times n}(\mathbb{F})\)</span> 행렬의 각 행벡터에 대한 함수로 생각하자. 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 <span class="math inline">\(i\)</span> 번째 행을 <span class="math inline">\(\boldsymbol{A}_{i:}\)</span> 라고 하자. 이 때 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행렬식 <span class="math inline">\(\det(\boldsymbol{A})\)</span> 를 <span class="math inline">\(\det (\boldsymbol{A}_{1:},\ldots,\boldsymbol{A}_{n:})\)</span> 로 정의한다.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-determinant_of_matrix" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.7 (<span class="math inline">\(\det (\boldsymbol{A})\)</span>)</strong></span> <span class="math display">\[
\det (\boldsymbol{A}) = \det(\boldsymbol{A}_{1:},\ldots,\boldsymbol{A}_{n:}) = \sum_{\sigma\in S_n} \text{sgn}(\sigma) \prod_{i=1}^n A_{i\sigma(i)}
\]</span></p>
</div>
</div>
</div>
</div>
<p>이제 앞서의 증명들로부터 <span class="math inline">\(n\times n\)</span> 행렬에 대한 행렬식 <span class="math inline">\(\boldsymbol{A}\)</span> 에 대해 다음이 성립함을 쉽게 보일 수 있다.</p>
<p><br></p>
<div id="prp-elementary_row_operation_and_determinant" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.12 (행 기본 연산과 행렬식)</strong></span> <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n\times n}(\mathbb{F})\)</span> 라고 하자. <a href="#def-elementary_row_operation" class="quarto-xref">정의&nbsp;<span>3.1</span></a> 에서 정의된 행 기본연산 <span class="math inline">\(E^{(1)},\, E^{(2)},\, E^{(3)}\)</span> 에 대해 다음이 성립한다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(\det(\boldsymbol{I}_n) = 1\)</span></p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\(\det\left(E^{(1)}(i, j)\boldsymbol{A}\right) = -\det(\boldsymbol{A})\)</span>.</p>
<p>  (<span class="math inline">\(3\)</span>) <span class="math inline">\(\det\left(E^{(2)}(i, t)\boldsymbol{A}\right) = t\det(\boldsymbol{A})\)</span>.</p>
<p>  (<span class="math inline">\(4\)</span>) <span class="math inline">\(\det \left( E^{(3)}(i,j, r)\boldsymbol{A} \right) = \det(\boldsymbol{A})\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(1\)</span>) <a href="#exr-determinant_of_identity" class="quarto-xref">연습문제&nbsp;<span>3.2</span></a></p>
<p>(<span class="math inline">\(2\)</span>) <a href="#prp-altermating_form_of_determinant" class="quarto-xref">명제&nbsp;<span>3.8</span></a></p>
<p>(<span class="math inline">\(3\)</span>) <a href="#prp-bilinearity_of_determinant" class="quarto-xref">명제&nbsp;<span>3.9</span></a></p>
<p>(<span class="math inline">\(4\)</span>) <a href="#prp-determinant_scala_multiple" class="quarto-xref">명제&nbsp;<span>3.10</span></a></p>
</div>
<p><br></p>
<p>이제 행렬식에서 중요한 결과 몇가지를 차례로 보일 것이다.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-transposed_matrix" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.8 (전치행렬)</strong></span> <span class="math inline">\(m\times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{A} \in \mathcal{M}_{m \times n}(\mathbb{F})\)</span> 에 대해 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행과 열을 바꾼 행렬을 <span class="math inline">\(\boldsymbol{A}\)</span> 의 <strong>전치 행렬 (transposed matrix)</strong> 라 하며 <span class="math inline">\(\boldsymbol{A}^T\)</span> 라 쓴다. 즉,</p>
<p><span class="math display">\[
\left(\boldsymbol{A}^T \right)_{ij} = (\boldsymbol{A})_{ji}, \qquad i=1,\ldots, n,\, j = 1,\ldots, m
\]</span></p>
<p>이다. 이 때 <span class="math inline">\(\boldsymbol{A}^T\)</span> 는 <span class="math inline">\(n \times m\)</span> 행렬이다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div id="exm-transpose_matrix" class="theorem example">
<p><span class="theorem-title"><strong>보기 3.5 (전치행렬의 성질)</strong></span> <span class="math inline">\(\boldsymbol{A}\)</span> 가 <span class="math inline">\(m \times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{B}\)</span> 가 <span class="math inline">\(n \times l\)</span> 행렬이며 <span class="math inline">\(\lambda \in \mathbb{F}\)</span> 일 때 다음이 성립한다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(\left(\boldsymbol{A}^{T}\right)^{T} = \boldsymbol{A}\)</span>,</p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\((\lambda \boldsymbol{A})^T = \lambda (\boldsymbol{A})^T\)</span></p>
<p>  (<span class="math inline">\(3\)</span>) <span class="math inline">\((\boldsymbol{AB})^T = \boldsymbol{B}^T\boldsymbol{A}^T\)</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(\text{3}\)</span>) 만을 증명한다.</p>
<p><span class="math display">\[
\begin{aligned}
\left(\left( \boldsymbol{AB} \right)^T \right)_{ij} = (\boldsymbol{AB})_{ji} = \sum_{k=1}^n A_{jk} B_{ki} = \sum_{k=1}^n \left( \boldsymbol{B}^T\right)_{ik}\left(\boldsymbol{A}^T\right)_{kj} = (\boldsymbol{B}^T\boldsymbol{A}^T)_{ij}
\end{aligned}
\]</span> <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div id="prp-determinant_of_transpose" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.13</strong></span> <span class="math inline">\(n\times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 에 대해 <span class="math inline">\(\det (\boldsymbol{A}^T) = \det (\boldsymbol{A})\)</span> 이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>전치행렬 <span class="math inline">\(\boldsymbol{A}^T\)</span> 의 행렬식은 <span class="math display">\[
\begin{aligned}
\det (\boldsymbol{A}^T) &amp;= \sum_{\sigma \in S_n} \text{sgn}(\sigma) \prod_{i=1} A_{\sigma(i) i}
\end{aligned}
\]</span></p>
<p>이다. <span class="math inline">\(j = \sigma (i)\)</span> 라 하면, <span class="math inline">\(i=\sigma^{-1}(j)\)</span> 이고 <span class="math inline">\(\text{sgn} (\sigma) = \text{sgn}(\sigma^{-1})\)</span> 이므로, <span class="math display">\[
\prod_{i=1}^n A_{\sigma(i)i} = \prod_{j=1}^n A_{j\sigma^{-1}(j)}
\]</span></p>
<p>이다. <a href="#prp-basic_properties_of_permutation" class="quarto-xref">명제&nbsp;<span>3.3</span></a> 의 4. 에서 보였듯이 <span class="math inline">\(\{\sigma^{-1} : \sigma\in S_n\} = S_n\)</span> 이므로<br>
<span class="math display">\[
\begin{aligned}
\det(\boldsymbol{A}^T) &amp;= \sum_{\sigma\in S_n} \text{sgn}(\sigma^{-1}) \prod_{j=1}^n A_{j\sigma^{-1}(j)} = \sum_{\sigma^{-1}\in S_n }\text{sgn}(\sigma^{-1}) \prod_{j=1}^n A_{j\sigma^{-1}(j)} \\
&amp;=\det(\boldsymbol{A})
\end{aligned}
\]</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>이제 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행들 <span class="math inline">\(\{\boldsymbol{A}_{1:},\ldots,\,\boldsymbol{A}_{n:}\}\)</span> 에 대한 <a href="#prp-elementary_row_operation_and_determinant" class="quarto-xref">명제&nbsp;<span>3.12</span></a> 가 열들 <span class="math inline">\(\{\boldsymbol{A}_{:1},\ldots,\boldsymbol{A}_{:n}\}\)</span> 에 대해서도 똑같이 성립한다는 것은 쉽게 보일 수 있다.</p>
<p><br></p>
<div id="prp-elementary_column_operation_and_determinant" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.14 (행렬의 열에 대한 연산과 행렬식)</strong></span> <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n\times n}(\mathbb{F})\)</span> 라고 하자.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 의 두 열을 바꾸었을 때의 행렬식은 원래의 행렬식에 <span class="math inline">\(-1\)</span> 을 곱한 값이다.</p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 의 한 열에 상수 <span class="math inline">\(c\)</span> 를 곱한 행렬의 행렬식은 원래의 행렬식에 <span class="math inline">\(c\)</span> 를 곱한 값이다.</p>
<p>  (<span class="math inline">\(3\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 의 <span class="math inline">\(i\)</span> 번째 열에 <span class="math inline">\(c \times\)</span> [<span class="math inline">\(j\)</span> 번째 열] 을 더한 행렬의 행렬식은 원래 행렬식과 같다.</p>
</div>
<p><br></p>
<p>이제 행렬식과 정사각 행렬의 성질에 관한 중요한 명제를 제시한다. 증명은 이미 우리가 했다.</p>
<div id="prp-zero_determinant_of_linear_dependency" class="theorem proposition page-columns page-full">
<div class="page-columns page-full"><p><span class="theorem-title"><strong>명제 3.15</strong></span> 정사각행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행벡터가 선형 종속일 경우 그 행렬식은 <span class="math inline">\(0\)</span> 이다. <span class="math inline">\(\boldsymbol{A}\)</span> 의 열벡터가 선형 종속이어도 그 행렬식은 <span class="math inline">\(0\)</span> 이다. </p><div class="no-row-height column-margin column-container"><span class="margin-aside">이 명제의 역, 즉 행렬식이 <span class="math inline">\(0\)</span> 경우 행벡터와 열벡터가 선형독립인 것은 이후에 보이게 된다. (<a href="#prp-determinant_of_invertible_matrix" class="quarto-xref">명제&nbsp;<span>3.25</span></a>)</span></div></div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><a href="#prp-linear_dependency_and_determinant" class="quarto-xref">명제&nbsp;<span>3.11</span></a></p>
</div>
<p><br></p>
<div id="prp-determinant_product_of_matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.16</strong></span> <span class="math inline">\(n \times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{A},\,\boldsymbol{B}\)</span> 에 대해 <span class="math inline">\(\det (\boldsymbol{AB})= \det(\boldsymbol{A})\det (\boldsymbol{B})\)</span> 이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>행렬 <span class="math inline">\(\boldsymbol{AB}\)</span> 의 <span class="math inline">\(j\)</span> 번째 행 <span class="math inline">\((\boldsymbol{AB})_{j:}\)</span> 는 다음과 같이 표현 할 수 있다. <span class="math display">\[
\begin{aligned}
(\boldsymbol{AB})_{j:} &amp;= A_{j1}\boldsymbol{B}_{1:} + \cdots + A_{jn}\boldsymbol{B}_{n:}
\end{aligned}
\]</span></p>
<p>그렇다면,</p>
<p><span class="math display">\[
\begin{aligned}
\det(\boldsymbol{AB}) &amp;= \det (A_{11}\boldsymbol{B}_{1:}+ \cdots + A_{1n}\boldsymbol{B}_{n:}, \ldots ,A_{n1}\boldsymbol{B}_{1:}+ \cdots + A_{nn}\boldsymbol{B}_{n:} ) \\
&amp;= \sum_{i_1=1}^n A_{1,i_1} \det (\boldsymbol{B}_{i_1:}, A_{21}\boldsymbol{B}_{1:}+ \cdots + A_{2n}\boldsymbol{B}_{n:}, \ldots ,A_{n1}\boldsymbol{B}_{1:}+ \cdots + A_{nn}\boldsymbol{B}_{n:} ) \\
&amp;\qquad \vdots \\
&amp;=\sum_{i_1=1}^n \cdots \sum_{i_n=1}^n A_{1,i_1} \cdots A_{n, {i_n}} \det(\boldsymbol{B}_{i_1:}, \ldots, \boldsymbol{B}_{i_n,n}) \\
\end{aligned}
\]</span></p>
<p>여기서 <span class="math inline">\(\sigma_{i_1,\ldots,i_n} = \begin{pmatrix} 1 &amp; 2 &amp; \cdots &amp; n \\ i_1 &amp; i_2 &amp; \cdots &amp; i_n\end{pmatrix}\)</span> 라 하면, <a href="#exr-determinant_change_of_order" class="quarto-xref">연습문제&nbsp;<span>3.3</span></a> 에서 보았듯이 <span class="math display">\[
\begin{aligned}
\det (\boldsymbol{AB}) &amp;= \sum_{i_1=1}^n \cdots \sum_{i_n=1}^n A_{1,i_1} \cdots A_{n, {i_n}} \text{sgn}(\sigma_{i_1,\ldots,i_n}) \det(\boldsymbol{B}_{1:}, \ldots, \boldsymbol{B}_{n:}) \\
&amp;= \det(\boldsymbol{B}) \left(\sum_{i_1=1}^n \cdots \sum_{i_n=1}^n \text{sgn}(\sigma_{i_1,\ldots,i_n}) A_{1,i_1} \cdots A_{n, {i_n}}\right) \\
&amp;= \det (\boldsymbol{B}) \det (\boldsymbol{A}) = \det (\boldsymbol{A})\det (\boldsymbol{B})
\end{aligned}
\]</span></p>
<p>이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>아직 우리는 가역행렬과 행렬식의 관계에 대해 알아보지 않았다. 다음 장에서 보이겠지만 어떤 정사각 행렬의 행렬식이 <span class="math inline">\(0\)</span> 이 아니라는 것과 그 행렬이 가역행렬이라는 것은 동치이다. 즉 가역행렬의 행렬식은 <span class="math inline">\(0\)</span> 이 아니라는 것을 잠시동안 우리가 알고 있다고 가정하자. 그렇다면 아래의 유용한 성질을 알게 된다.</p>
<div id="cor-derterminant_of_inverse_matrix" class="theorem corollary">
<p><span class="theorem-title"><strong>따름정리 3.1</strong></span> <span class="math inline">\(n\times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 가 가역행렬일 때 <span class="math inline">\(\det (\boldsymbol{A}^{-1}) = \dfrac{1}{\det (\boldsymbol{A})}\)</span> 이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{AA}^{-1}=\boldsymbol{I}\)</span> 이며 <span class="math inline">\(\det (\boldsymbol{I})=1\)</span> 이므로,</p>
<p><span class="math display">\[
\det(\boldsymbol{A})\det (\boldsymbol{A}^{-1}) = \det(\boldsymbol{AA}^{-1}) = \det (\boldsymbol{I}) =1
\]</span></p>
<p>이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
</section>
<section id="다양한-행렬의-행렬식" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="다양한-행렬의-행렬식"><span class="header-section-number">3.5</span> 다양한 행렬의 행렬식</h2>
<section id="기본적인-행렬과-행렬식" class="level3" data-number="3.5.1">
<h3 data-number="3.5.1" class="anchored" data-anchor-id="기본적인-행렬과-행렬식"><span class="header-section-number">3.5.1</span> 기본적인 행렬과 행렬식</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-basic_matrix_notation" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.9 (기본적인 행렬)</strong></span> &nbsp;</p>
<ol type="1">
<li><p>행의 갯수와 열의 갯수가 같은 행렬을 <strong>정사각 행렬(square matrix)</strong> 라 한다.</p></li>
<li><p>행렬에서 행과 열이 같은 위치의 성분을 <strong>대각성분 (diagonal elements)</strong> 이라 한다. 즉 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 에서 <span class="math inline">\(A_{ii}\)</span> 들이 대각성분이다.</p></li>
<li><p>항등행렬 <span class="math inline">\(\boldsymbol{I}_n \in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 는 정사각행렬이며 대각성분이 <span class="math inline">\(1\)</span> 이고 나머지 성분은 <span class="math inline">\(0\)</span> 인 행렬이다. 즉 <span class="math inline">\((\boldsymbol{I}_n)_{ij}=\delta_{ij}\)</span> 로 정의된다. <span class="math inline">\(\boldsymbol{v} \in \mathcal{M}_{n}(\mathbb{F})\)</span> 에 대해, <span class="math inline">\(\boldsymbol{I}_n\boldsymbol{v}=\boldsymbol{v}\)</span> 이며 <span class="math inline">\(n \times m\)</span> 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 와 <span class="math inline">\(m \times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{B}\)</span> 에 대해 <span class="math inline">\(\boldsymbol{I}_n\boldsymbol{A}=\boldsymbol{A},\, \boldsymbol{B}\boldsymbol{I}_n=\boldsymbol{B}\)</span> 이므로 항등행렬이라 불린다. 임의의 크기의 항등행렬을 <span class="math inline">\(\boldsymbol{I}\)</span> 으로 표현한다.</p></li>
<li><p>정사각행렬에서 대각성분을 제외한 모든 성분이 <span class="math inline">\(0\)</span> 일 때 <strong>대각 행렬 (diagonal matrix)</strong> 라 한다. 대각성분의 아래 행이 모두 <span class="math inline">\(0\)</span> 인 행렬을 <strong>상 삼각 행렬 (upper triangular matrix)</strong> 라 한다. 대각성분의 위 행이 모두 <span class="math inline">\(0\)</span> 인 행렬을 <strong>하 삼각 행렬 (lower triangular matrix)</strong> 라고 한다. 예를 들어 아래 행렬에서 <span class="math inline">\(\boldsymbol{D}\)</span> 는 대각행렬, <span class="math inline">\(\boldsymbol{U}\)</span> 는 상삼각행렬, <span class="math inline">\(\boldsymbol{L}\)</span> 은 하삼각행렬이다.</p></li>
</ol>
<p><span class="math display">\[
\boldsymbol{D} = \begin{pmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 2 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{pmatrix},\qquad \boldsymbol{U} = \begin{pmatrix} 1 &amp; 3 &amp; 2 \\ 0 &amp; 2 &amp; 1 \\ 0 &amp; 0 &amp; 3 \end{pmatrix} , \qquad \boldsymbol{L} = \begin{pmatrix} 3 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 0 \\ 2 &amp; 5 &amp; 1\end{pmatrix}
\]</span></p>
<ol start="6" type="1">
<li><span class="math inline">\(n \times n\)</span> 정사각 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 에 대해 어떤 <span class="math inline">\(n \times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{B}\)</span> 가 존재하여 <span class="math inline">\(\boldsymbol{AB}=\boldsymbol{BA}=\boldsymbol{I}_n\)</span> 일 때 <span class="math inline">\(\boldsymbol{A}\)</span> 를 <strong>가역행렬 (invertible matrix)</strong> 라 하고, <span class="math inline">\(\boldsymbol{B}\)</span> 를 <span class="math inline">\(\boldsymbol{A}\)</span> 의 <strong>역행렬(inverse matrix)</strong> 이라 한다. <span class="math inline">\(\boldsymbol{A}\)</span> 의 역행렬은 <span class="math inline">\(\boldsymbol{A}^{-1}\)</span> 로 표현한다.</li>
</ol>
</div>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="sec-basic_properties_of_matrix" class="level3" data-number="3.5.2">
<h3 data-number="3.5.2" class="anchored" data-anchor-id="sec-basic_properties_of_matrix"><span class="header-section-number">3.5.2</span> 행렬에 대한 몇가지 기본적인 성질들</h3>
<p>이제 행렬의 몇가지 기본적인 성질들을 보이려고 한다. 이것들은 유용하긴 하지만 Theorem 이나 Lemma, Proposition 등의 좀 거창인 이름을 붙일 정도는 아니기 때문에 <strong>보기</strong> 로 돌린다.</p>
<p><br></p>
<div id="exm-multiplication_of_diagonal_matrix" class="theorem example">
<p><span class="theorem-title"><strong>보기 3.6</strong></span> 대각행렬의 곱은 대각행렬이다. 상 삼각 행렬의 곱은 상 삼각 행렬이다. 하 삼각 행렬의 곱은 하 삼각 행렬이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{D},\,\boldsymbol{F}\)</span> 가 모두 <span class="math inline">\(n \times n\)</span> 대각행렬이라 하자. <span class="math inline">\(D_{ij} = d_i \delta_{ij},\, F_{ij} = f_i \delta_{ij}\)</span> 이므로,</p>
<p><span class="math display">\[
(\boldsymbol{DF})_{ij} = \sum_k D_{ik}F_{kj} = \sum_k d_i \delta_{ik} f_j \delta_{kj} = d_i f_i \delta_{ij}
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{DF}\)</span> 는 대각행렬이다.</p>
<p><span class="math inline">\(\boldsymbol{U},\, \boldsymbol{V}\)</span> 가 모두 <span class="math inline">\(n \times n\)</span> 상삼각행렬이라 하자. <span class="math inline">\(i&gt;j\)</span> 에 대해 <span class="math inline">\(U_{ij}=0,\, V_{ij}=0\)</span> 이므로,</p>
<p><span class="math display">\[
(\boldsymbol{UV})_{ij} = \sum_k U_{ik}V_{kj} = \sum_{k\ge i, k \le j} U_{ik}V_{kj}
\]</span></p>
<p>이다. 그런데 <span class="math inline">\(i&gt;j\)</span> 이면 <span class="math inline">\(i \le k \le j\)</span> 인 <span class="math inline">\(k\)</span> 가 존재하지 않으므로 <span class="math inline">\((\boldsymbol{UV})_{ij} =0\)</span> 이다. 즉 <span class="math inline">\(\boldsymbol{UV}\)</span> 는 상 삼각 행렬이다. 하삼각 행렬의 곱이 하삼각행렬이라는 것은 비슷한 방법으로 보일 수 있다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div id="exm-determinant_of_upper_lower_triangular_matrix" class="theorem example">
<p><span class="theorem-title"><strong>보기 3.7</strong></span> 대각 행렬, 상 삼각 행렬과 하삼각 행렬의 행렬식은 그 대각성분의 곱과 같다. <span class="math inline">\(\boldsymbol{A}\)</span> 가 대각행렬, 상 삼각 행렬 혹은 하 삼각 행렬일 때,</p>
<p><span class="math display">\[
\det (\boldsymbol{A}) = \prod_{i=1}^n A_{ii}
\]</span></p>
<p>이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(n\times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 가 상삼각 행렬 이라 하자. <span class="math inline">\(i&gt;j\)</span> 이면 <span class="math inline">\(A_{ij}=0\)</span> 이다. <span class="math display">\[
\det (\boldsymbol{A}) = \sum_{\sigma \in S_n} \text{sgn}(\sigma) \prod_{i=1}^n A_{i \sigma(i)}
\]</span> 에서 <span class="math inline">\(\displaystyle \prod_{i=1}^n A_{i\sigma(i)} \ne 0\)</span> 이려면 모든 <span class="math inline">\(i=1,\ldots,\,n\)</span> 에 대해 <span class="math inline">\(\sigma(i)\ge i\)</span> 이어야 한다. 그런데 가능한 경우는 <span class="math inline">\(\sigma(1) = 1,\, \sigma(2) = 2,\ldots\)</span> 일 수 밖에 없으며 따라서, <span class="math display">\[
\det (\boldsymbol{A}) = \text{sgn}(i_d) A_{11} \cdots A_{nn} = \prod_{i=1}^n A_{ii}
\]</span> 이다. <span class="math inline">\(\boldsymbol{B}\)</span> 가 하 삼각 행렬이면 <span class="math inline">\(\boldsymbol{B}^T\)</span> 는 상 삼각 행렬이므로 역시 행렬식은 대각성분의 곱이다. 대각행렬은 상삼각행렬이며 하 삼각 행렬이므로 역시 그 행렬식은 대각성분의 곱이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
<section id="블록-행렬의-행렬식" class="level3" data-number="3.5.3">
<h3 data-number="3.5.3" class="anchored" data-anchor-id="블록-행렬의-행렬식"><span class="header-section-number">3.5.3</span> 블록 행렬의 행렬식</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-block_matrix" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.10 (블록 행렬)</strong></span> 행렬을 정사각형, 혹은 직사각형의 구획으로 겹치거나 빠지지 않게 나누었을 때 각각의 구획을 부분행렬이라 하고, 행렬을 부분행렬로 표현한 것을 블록행렬이라 한다. 예를 들어</p>
<p><span class="math display">\[
\boldsymbol{A} = \left[ \begin{array}{rrr:rr} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\ 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 \\ \hdashline  11 &amp; 12 &amp; 13 &amp; 14&amp; 15 \end{array} \right]
\]</span></p>
<p>라 했을 때, 점선을 따라 부분행렬을 나누어 아래와 같이 정하면,</p>
<p><span class="math display">\[
\boldsymbol{A}_1 = \begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 6 &amp; 7 &amp; 8\end{bmatrix},\, \boldsymbol{A}_2 = \begin{bmatrix} 4 &amp; 5 \\ 9 &amp; 10 \end{bmatrix},\, \boldsymbol{A}_3 = \begin{bmatrix} 11 &amp; 12 &amp; 13 \end{bmatrix},\, \boldsymbol{A}_4 = \begin{bmatrix} 14 &amp; 15 \end{bmatrix}
\]</span></p>
<p>행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 는 부분행렬을 이용하여</p>
<p><span class="math display">\[
\boldsymbol{A} = \begin{bmatrix} \boldsymbol{A}_1 &amp; \boldsymbol{A}_2 \\ \boldsymbol{A}_3 &amp; \boldsymbol{A}_4 \end{bmatrix}
\]</span></p>
<p>라 표현할 수 있다. 같은 행의 부분행렬끼리는 행의 개수가 같고, 같은 열의 부분행렬끼리는 열의 개수가 같게 된다. 행렬 <span class="math inline">\(\boldsymbol{A}_1,\,\boldsymbol{A}_2,\,\boldsymbol{A}_3\)</span> 가 부분행렬 <span class="math inline">\(\boldsymbol{B},\,\boldsymbol{C},\, \boldsymbol{D}\)</span> 에 대해</p>
<p><span class="math display">\[
\boldsymbol{A}_D = \begin{bmatrix} \boldsymbol{B}&amp; \boldsymbol{0} \\ \boldsymbol{0} &amp; \boldsymbol{D} \end{bmatrix}, \qquad \boldsymbol{A}_U = \begin{bmatrix} \boldsymbol{B}&amp; \boldsymbol{C} \\ \boldsymbol{0} &amp; \boldsymbol{D} \end{bmatrix},\qquad \boldsymbol{A}_L = \begin{bmatrix} \boldsymbol{B}&amp; \boldsymbol{0} \\ \boldsymbol{C} &amp; \boldsymbol{D} \end{bmatrix},
\]</span></p>
<p>형태라고 하자. <span class="math inline">\(\boldsymbol{A}_D\)</span> 형태이면 <strong>블록 대각 행렬</strong>, <span class="math inline">\(\boldsymbol{A}_U\)</span> 형태이면 <strong>블록 상삼각 행렬</strong>, <span class="math inline">\(\boldsymbol{A}_D\)</span> 형태이면 <strong>블록 하삼각 행렬</strong> 이라고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div id="prp-determinant_of_block_matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.17 (블록대각행렬의 행렬식)</strong></span> <span class="math inline">\(\boldsymbol{B} \in \mathcal{M}_{m \times m}(\mathbb{F}),\, \boldsymbol{D}\in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 에 대해 블록 정사각 행렬 <span class="math inline">\(\boldsymbol{A}= \begin{bmatrix} \boldsymbol{B}&amp; \boldsymbol{0} \\ \boldsymbol{0} &amp; \boldsymbol{D}\end{bmatrix} \in \mathcal{M}_{(m+n)\times (m+n)}(\mathbb{F})\)</span> 의 행렬식이 <span class="math inline">\(\det (\boldsymbol{A}) = \det(\boldsymbol{B}) \det(\boldsymbol{D})\)</span> 임을 보여라.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>행렬식의 정의에 의해 <span class="math display">\[
\begin{aligned}
\det (\boldsymbol{A}) &amp;= \sum_{\sigma \in S_{m+n}} \text{sgn}(\sigma) \prod_{i=1}^{m+n} A_{i, \sigma(i)} \\
&amp;=  \sum_{\sigma \in S_{m+n}} \text{sgn}(\sigma) \prod_{i=1}^m A_{i, \sigma(i)} \prod_{i=m+1}^{m+n} A_{i,\sigma(i)}
\end{aligned}
\]</span></p>
<p>이다.</p>
<p><span class="math inline">\(1\le i \le m\)</span> 에 대해 <span class="math inline">\(\sigma(i)&gt;m\)</span> 이면 <span class="math inline">\(A_{i,\sigma(i)}=0\)</span> 이며 <span class="math inline">\(m+1 \le i \le m+n\)</span> 에 대해 <span class="math inline">\(\sigma(i)\le m\)</span> 이면 <span class="math inline">\(A_{i, \sigma(i)} = 0\)</span> 이다. 즉 <span class="math inline">\(\prod_{i=1}^m A_{i, \sigma(i)}\)</span> 부분은 <span class="math inline">\(\{1,\ldots,\,m\}\)</span> 에 대한 순열만이 의미있으며, <span class="math inline">\(\prod_{i=m+1}^{m+n} D_{i,\sigma(i)}\)</span> 부분은 <span class="math inline">\(\{m+1,\ldots,m+n\}\)</span> 에 대한 순열만이 의미있다.</p>
<p>이제 <span class="math inline">\(\{1,\ldots,\,m\}\)</span> 에 대한 순열 <span class="math inline">\(S_m\)</span> 과 <span class="math inline">\(\{m+1,\ldots,\,m+n\}\)</span> 에 대한 순열 <span class="math inline">\(S'\)</span> 을 생각하자. <span class="math inline">\(\tau \in S_m,\, \zeta \in S'\)</span> 에 대해 <span class="math inline">\(\tau\zeta \in S_{m+n}\)</span> 이며 <span class="math inline">\(\sigma = \tau \zeta\)</span> 일 때 <span class="math inline">\(\text{sgn}(\sigma) = \text{sgn}(\tau)\,\text{sgn}(\zeta)\)</span> 이다. 또한 어떤 <span class="math inline">\(\tau \in S_m,\, \zeta\in S'\)</span> 에 대해 <span class="math inline">\(\sigma = \tau \zeta\)</span> 가 되지 않으면 행렬식에 대한 기여가 <span class="math inline">\(0\)</span> 이 된다. 따라서,</p>
<p><span class="math display">\[
\begin{aligned}
\det (\boldsymbol{D}) &amp;= \sum_{\tau \in S_m,\, \zeta \in S'} \text{sgn}(\tau)\text{sgn}(\zeta)\prod_{i=1}^m A_{i, \tau(i)} \prod_{j=m+1}^{m+n} B_{j-m, \sigma(j-m)-m}  \\
&amp;= \left(\sum_{\tau \in S_m}\text{sgn}(\tau)\prod_{i=1}^m A_{i, \tau(i)}\right) \left( \sum_{\zeta \in S'} \text{sgn}(\zeta) \prod_{j=m+1}^{m+n} B_{j-m, \sigma(j-m)-m} \right) \\
&amp;= \det (\boldsymbol{A}) \det(\boldsymbol{B})
\end{aligned}
\]</span></p>
<p>이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div id="prp-determinant_of_bloc_triangular_matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.18 (블록 삼각행렬의 행렬식)</strong></span> <span class="math inline">\(\boldsymbol{B}\in \mathcal{M}_{m \times m}(\mathbb{F}),\, \boldsymbol{D}\in \mathcal{M}_{n\times n}(\mathbb{F}),\, \boldsymbol{C}=\mathcal{M}_{n \times m}(\mathbb{F})\)</span> 에 대해</p>
<p><span class="math display">\[
\det \left(\begin{bmatrix} \boldsymbol{B} &amp; \boldsymbol{0}\\  \boldsymbol{C} &amp; \boldsymbol{D} \end{bmatrix}\right) = \det(\boldsymbol{B})\cdot \det(\boldsymbol{D})
\]</span></p>
<p>임을 보여라.</p>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span><span class="math inline">\(\boldsymbol{B}\)</span> 가 가역행렬이 아니라면 가우스 소거법으로 <span class="math inline">\(1\)</span> 행부터 <span class="math inline">\(m\)</span> 행 까지 중에 <span class="math inline">\(0\)</span> 으로만 이루어지 행을 만들 수 있으며 따라서 행렬식은 <span class="math inline">\(0\)</span> 이다. <span class="math inline">\(\boldsymbol{A}\)</span> 가 가역행렬이라면</p>
<p><span class="math display">\[
\begin{bmatrix}\boldsymbol{I}_m &amp; \boldsymbol{0} \\ -\boldsymbol{CA}^{-1} &amp; \boldsymbol{I}_n \end{bmatrix} \begin{bmatrix} \boldsymbol{A} &amp; \boldsymbol{0}\\  \boldsymbol{C} &amp; \boldsymbol{B} \end{bmatrix} = \begin{bmatrix} \boldsymbol{A} &amp; \boldsymbol{0} \\ \boldsymbol{0} &amp; \boldsymbol{B}\end{bmatrix}
\]</span></p>
<p>첫번째 행렬은 하삼각행렬이므로 행렬식은 대각성분의 곱인 <span class="math inline">\(1\)</span> 이다. <a href="#prp-determinant_of_block_matrix" class="quarto-xref">명제&nbsp;<span>3.17</span></a> 을 보라.</p>
</div>
<p><br></p>
<div id="exm-inverse_matrix" class="theorem example">
<p><span class="theorem-title"><strong>보기 3.8 (역행열의 성질)</strong></span> <span class="math inline">\(\boldsymbol{A},\,\boldsymbol{B}\)</span> 가 가역행렬이고 <span class="math inline">\(\lambda \in \mathbb{F}\)</span> 일 때 다음이 성립한다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(\left(\boldsymbol{A}^{-1}\right)^{-1} = \boldsymbol{A}\)</span>,</p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\((\lambda\boldsymbol{A})^{-1} = \dfrac{1}{\lambda} \boldsymbol{A}^{-1}\)</span>,</p>
<p>  (<span class="math inline">\(3\)</span>) <span class="math inline">\((\boldsymbol{AB})^{-1} = \boldsymbol{B}^{-1}\boldsymbol{A}^{-1}\)</span>,</p>
</div>
<p><br></p>
<div id="cor-derterminant_is_invariant_under_similar_transformation" class="theorem corollary">
<p><span class="theorem-title"><strong>따름정리 3.2</strong></span> 정사각 행렬에 대한 행렬식은 닮음 변환에 대해 불변이다. 즉 <span class="math inline">\(\boldsymbol{A},\, \boldsymbol{P} \in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 이고 <span class="math inline">\(\boldsymbol{P}\)</span> 가 가역일 때 <span class="math inline">\(\det (\boldsymbol{P}^{-1}\boldsymbol{AP}) = \det (\boldsymbol{A})\)</span> 이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\det (\boldsymbol{P}^{-1}\boldsymbol{AP}) = \det (\boldsymbol{P}^{-1})\det (\boldsymbol{A})\det (\boldsymbol{P}) = 1. \qquad \square\)</span></p>
</div>
<p><br></p>
</section>
</section>
<section id="sec-linear_map_understood_by_RREM" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="sec-linear_map_understood_by_RREM"><span class="header-section-number">3.6</span> 행간소 사다리꼴 행렬을 통한 선형사상의 이해</h2>
<p>우리는 앞장에서 행 간소 사다리꼴을 구하는 방법을 배웠지만 그것이 얼마나 유용한지, 어디에 사용하는지는 직접접으로 보이지 않았다. 이제 행 간소 사다리꼴이 왜 필요한지에 대해 알아볼 것이다. 그러나 거기까지 가기 전에 조금 준비운동이 필요하다.</p>
<p><br></p>
<section id="sec-row_space_and_column_space" class="level3" data-number="3.6.1">
<h3 data-number="3.6.1" class="anchored" data-anchor-id="sec-row_space_and_column_space"><span class="header-section-number">3.6.1</span> 행공간과 열공간</h3>
<p>행렬의 행벡터와 열벡터에 의해 span 되는 벡터공간을 생각 할 수 있으며 이를 각각 행공간 열공간이라고 한다.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-column_space_row_space" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.11 (행공간, 열공간)</strong></span> 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 모든 행벡터에 의해 span 되는 벡터공간을 <span class="math inline">\(\boldsymbol{A}\)</span> 의 <strong>행공간 (row space)</strong> 이라고 한다. 마찬가지로 모든 열벡터에 의해 span 되는 벡터공간을 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 <strong>열공간 (column space)</strong> 라고 한다. 따라서 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행공간은 <span class="math inline">\(\text{span}(\boldsymbol{A}_{1:},\, \boldsymbol{A}_{2:},\ldots)\)</span> 이며 열공간은 <span class="math inline">\(\text{span}(\boldsymbol{A}_{:1}, \, \boldsymbol{A}_{:2},\ldots)\)</span> 이다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div id="exm-column_space_row_space" class="theorem example">
<p><span class="theorem-title"><strong>보기 3.9</strong></span> <span class="math inline">\(\boldsymbol{A} \in \mathcal{M}_{m \times n}(\mathbb{F})\)</span> 이라면 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행공간은 <span class="math inline">\(\mathcal{M}_{1 \times n}(\mathbb{F})\)</span> 의 부분공간이며 <span class="math inline">\(\boldsymbol{A}\)</span> 의 열공간은 <span class="math inline">\(\mathcal{M}_{m}(\mathbb{F})\)</span> 의 부분공간이다.</p>
</div>
<p><br></p>
<p>선형사상에서 <span class="math inline">\(\ker,\, \text{im},\, \text{nullity},\, \text{rank}\)</span> 를 정의했듯이 행렬에 대해서도 정의 할 수 있다.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-kernel_of_matrox" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3.12 (행렬의 <span class="math inline">\(\ker\)</span> 과 <span class="math inline">\(\text{im}\)</span>)</strong></span> <span class="math inline">\(\boldsymbol{A} \in \mathcal{M}_{m \times n}(\mathbb{F})\)</span> 에 대해 <span class="math inline">\(\ker (\boldsymbol{A})\)</span>, <span class="math inline">\(\text{im} (\boldsymbol{A})\)</span>, <span class="math inline">\(\text{nullity} (\boldsymbol{A})\)</span>, <span class="math inline">\(\text{rank} (\boldsymbol{A})\)</span> 를 다음과 같이 정의한다.</p>
<p><span class="math display">\[
\begin{aligned}
\ker (\boldsymbol{A}) &amp;= \{ \boldsymbol{x} \in \mathcal{M}_{n}(\mathbb{F}) : \boldsymbol{Ax} = \boldsymbol{0}\}, \\
\text{im} (\boldsymbol{A}) &amp; = \{ \boldsymbol{Ax} : \boldsymbol{x} \in \mathcal{M}_n(\mathbb{F})\}, \\
\text{nullity} (\boldsymbol{A}) &amp;= \dim (\ker (\boldsymbol{A})), \\
\text{rank} (\boldsymbol{A}) &amp; =  \dim (\text{im} (\boldsymbol{A})).
\end{aligned}
\]</span></p>
</div>
</div>
</div>
</div>
<p><br></p>
<div id="prp-rank_of_matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.19</strong></span> 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 에 대해 <span class="math inline">\(\text{im}(\boldsymbol{A})\)</span> 는 <span class="math inline">\(\boldsymbol{A}\)</span> 의 열공간이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{A} = \begin{bmatrix} \boldsymbol{A}_{:1} &amp; \cdots &amp; \boldsymbol{A}_{:n}\end{bmatrix}\)</span> 이고 <span class="math inline">\(\boldsymbol{x} = \begin{bmatrix} x_1  &amp; \cdots &amp; x_n\end{bmatrix}^T\)</span> 라 하면,</p>
<p><span class="math display">\[
\boldsymbol{Ax} = x_1 \boldsymbol{A}_{:1} + \cdots + x_n \boldsymbol{A}_{:n}
\]</span></p>
<p>이다. 따라서 (이미 짐작 할 수 있듯이) <span class="math inline">\(\text{im} (\boldsymbol{A}) = \text{span}(\boldsymbol{A}_{:1}, \ldots, \boldsymbol{A}_{:n})\)</span> 이므로 <span class="math inline">\(\text{im}(\boldsymbol{A})\)</span> 는 <span class="math inline">\(\boldsymbol{A}\)</span> 의 열공간이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>우리는 앞서 가역 연산자는 기저를 다른 기저로 바꾸는 연산자라는 것을 알았다(<a href="ch1_02_linear_map.html#cor-basis_transformation" class="quarto-xref">따름정리&nbsp;<span>2.4</span></a>). 이제 가역변환에 의해 변하는 것과 변하지 않는 것을 알아보자.</p>
<div id="lem-same_range_reduced_echelon_form" class="theorem lemma">
<p><span class="theorem-title"><strong>보조정리 3.2</strong></span> <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{m \times n}(\mathbb{F})\)</span> 에 어떤 가역 변환 <span class="math inline">\(\boldsymbol{S}\)</span> 를 수행했을 때</p>
<p><span class="math display">\[
\begin{aligned}
\ker (\boldsymbol{A}) &amp;= \ker (\boldsymbol{SA}), \\
\text{rank} (\boldsymbol{A}) &amp;= \text{rank} (\boldsymbol{SA})
\end{aligned}
\]</span></p>
<p>이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{S}\)</span> 가 가역행렬이므로 <span class="math inline">\(\boldsymbol{Av}=\boldsymbol{0} \iff \boldsymbol{SAv}=\boldsymbol{0}\)</span> 이다. 따라서 <span class="math inline">\(\ker \boldsymbol{A} = \ker (\boldsymbol{SA})\)</span> 이다. 따라서 선형사상의 기본정리(<a href="ch1_02_linear_map.html#thm-rank_nullity" class="quarto-xref">정리&nbsp;<span>2.1</span></a>) 에 의해 <span class="math inline">\(\dim (\text{im} (\boldsymbol{A})) = \dim (\text{im} (\boldsymbol{SA}))\)</span> 이므로 <span class="math inline">\(\text{rank} (\boldsymbol{A}) = \text{rank} (\boldsymbol{SA})\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 가 유한번의 기본 행 연산을 통해 행 간소 사다리꼴 <span class="math inline">\(\boldsymbol{A}'\)</span> 이 되었다면 <span class="math inline">\(\boldsymbol{A}'\)</span> 을 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행 간소 사다리꼴 형태라고 부르겠다. 행렬과 행 간소 사다리꼴 형태에 대해 다음이 성립한다.</p>
<div id="prp-rank_of_reduced_echelon_form" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.20</strong></span> 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 와 행 간소 사다리꼴 형태 <span class="math inline">\(\boldsymbol{A}'\)</span> 에 대해 다음이 성립한다.</p>
<p><span class="math display">\[
\begin{aligned}
\ker (\boldsymbol{A}) &amp;= \ker (\boldsymbol{A}'), \\
\text{rank} (\boldsymbol{A}) &amp;= \text{rank} (\boldsymbol{A}').
\end{aligned}
\]</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>모든 행 기본 연산 행렬은 가역행렬이므로 <span class="math inline">\(\boldsymbol{A}'\)</span> 은 가역행렬과 <span class="math inline">\(\boldsymbol{A}\)</span> 의 곱이다. 따라서 <a href="#lem-same_range_reduced_echelon_form" class="quarto-xref">보조정리&nbsp;<span>3.2</span></a> 에 의해 위의 식이 성립한다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>행 간소 사다리꼴은 다음과 같은 형태이다. 선행 1 선분에는 밑줄을 그었다.</p>
<p><span class="math display">\[
\begin{bmatrix} 0 &amp; \underline{1} &amp; 2 &amp; 0 &amp; 0 &amp; 3 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; \underline{1} &amp; 0 &amp; 0 &amp; 3 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; \underline{1} &amp; 2 &amp; 3 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}
\]</span></p>
<p>행 간소 사다리꼴 행렬의 열벡터는 선행 1 성분을 포함하는 열과 포함하지 않는 열이 있다. 선행 1 성분을 포함하는 열은 1 성분을 제외한 성분이 모두 <span class="math inline">\(0\)</span> 이며, 영벡터를 포함하여 선행 1 성분을 포함하지 않는 열은 그 앞 열들의 선형결합이다. 따라서 우리는 다음을 알 수 있다.</p>
<div id="prp-dimension_of_row_space" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.21</strong></span> <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{m \times n}(\mathbb{F})\)</span> 과 그 행 간소 사다리꼴 행렬 <span class="math inline">\(\boldsymbol{A}'\)</span> 에 대해 다음이 성립한다. <span class="math display">\[
\text{rank} (\boldsymbol{A}) =\text{rank} (\boldsymbol{A}') = [\text{선행 1 성분의 개수}]
\]</span></p>
</div>
<p><br></p>
</section>
<section id="sec-rank_of_matrix" class="level3" data-number="3.6.2">
<h3 data-number="3.6.2" class="anchored" data-anchor-id="sec-rank_of_matrix"><span class="header-section-number">3.6.2</span> 행렬의 rank</h3>
<p><a href="#def-column_space_row_space" class="quarto-xref">정의&nbsp;<span>3.11</span></a> 에서 정의했듯이 <span class="math inline">\(m\times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 에서 <span class="math inline">\(\text{span}(\boldsymbol{A}_{1:},\ldots,\boldsymbol{A}_{:m})\)</span> 을 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행공간 이라 한다. 행렬의 행 기본 연산이 모두 행벡터들 사이의 선형결합이라는 것을 이해한다면, 아래 명제는 쉽게 이해 할 수 있다.</p>
<div id="prp-invariance_of_rowspace_by_row_operation" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.22</strong></span> <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{m \times n}(\mathbb{F})\)</span> 의 행공간은 행 기본연산에 의해 변하지 않는다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{A}\)</span> 가 행 기본 연산에 의해 변환된 행렬을 <span class="math inline">\(\boldsymbol{A}'\)</span> 이라 하자. 우리는 <span class="math inline">\(\text{rank}(\boldsymbol{A})=\text{rank}(\boldsymbol{A}')\)</span> 임을 알고 있다. <span class="math inline">\(\boldsymbol{a}\)</span> 가 <span class="math inline">\(\boldsymbol{A}'\)</span> 의 행공간에 포함된다면 모든 <span class="math inline">\(\boldsymbol{A}_{j:}\)</span> 는 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행공간에 포함되므로 <span class="math inline">\(\boldsymbol{a}\)</span> 역시 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행공간에 포함된다. 즉 <span class="math inline">\(\boldsymbol{A}'\)</span> 은 <span class="math inline">\(\boldsymbol{A}\)</span> 의 부분공간이다. 그런데 두 행공간의 차원이 같으므로 두 행공간은 같다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>따라서 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행공간과 그 행 간소 사다리꼴 형태 <span class="math inline">\(\boldsymbol{A}'\)</span> 의 행공간은 일치한다.</p>
<p>또하나의 중요한 사실은 행 간소 사다리꼴에서 <span class="math inline">\(0\)</span> 행을 제외한 행들은 모두 선형 독립이다. 영벡터가 아닌 행벡터는 모두 선행 1 성분을 가지고 있으며, 선행 1 성분이 있는 열은 선행 1 성분을 제외하면 모두 <span class="math inline">\(0\)</span> 이므로 영벡터가 아닌 행벡터는 선형 독립임을 알 수 있다. 즉</p>
<div id="prp-dimension_of_row_space" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.23</strong></span> <span class="math inline">\(\boldsymbol{A}\)</span> 의 행 간소 사다리꼴 형태를 <span class="math inline">\(\boldsymbol{A'}\)</span> 이라고 할 때 다음이 성립한다.</p>
<p><span class="math display">\[
\boldsymbol{A} \text{ 의 행공간의 차원} = \boldsymbol{A'} \text{ 의 행공간의 차원 } = [\text{선행 1 성분의 개수}].
\]</span></p>
</div>
<p><br></p>
<p><a href="#prp-dimension_of_row_space" class="quarto-xref">명제&nbsp;<span>3.23</span></a> 를 생각하면 다음과 같은 결론을 얻는다.</p>
<div id="thm-dimension_of_matrix" class="theorem">
<p><span class="theorem-title"><strong>정리 3.2</strong></span> <span class="math inline">\(m\times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 에 대해 다음이 성립한다. <span class="math display">\[
\text{rank}(\boldsymbol{A}) = \boldsymbol{A} \text{ 의 행공간의 차원 } = \boldsymbol{A} \text{ 의 열공간의 차원 }
\]</span></p>
</div>
<p><br></p>
</section>
<section id="sec-uniqueness_of_reduced_row_echelon_form" class="level3" data-number="3.6.3">
<h3 data-number="3.6.3" class="anchored" data-anchor-id="sec-uniqueness_of_reduced_row_echelon_form"><span class="header-section-number">3.6.3</span> 행 간소 사다리꼴의 유일성</h3>
<p>행렬의 행 간소 사다리꼴은 유일할까? 우리가 행렬을 행 간소 사다리꼴로 바꾸는 일관된 과정을 거쳤지만 다른 과정도 존재할 수 있다. 이제 어떤 방법으로른 행 간소 사다리꼴로 만들었다면 그 형태는 유일하다는 것을 보이고자 한다.</p>
<p><br></p>
<div id="thm-uniqueness_of_reduced_echelon_form" class="theorem">
<p><span class="theorem-title"><strong>정리 3.3</strong></span> 행렬의 행 간소 사다리꼴은 유일하다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 두 행간소 사다리꼴 형태를 <span class="math inline">\(\boldsymbol{S}\)</span> 와 <span class="math inline">\(\boldsymbol{T}\)</span> 라 하자.</p>
<p>(<span class="math inline">\(1\)</span>) <span class="math inline">\(\text{rank}(\boldsymbol{S}) = \text{rank}(\boldsymbol{T})\)</span> 이며 이 값은 <span class="math inline">\(\boldsymbol{S}\)</span> 와 <span class="math inline">\(\boldsymbol{T}\)</span> 의 <span class="math inline">\(0\)</span> 행이 아닌 행의 갯수이므로 <span class="math inline">\(\boldsymbol{S}\)</span> 와 <span class="math inline">\(\boldsymbol{T}\)</span> 는 같은 수의 <span class="math inline">\(0\)</span> 행이 아닌 행을 가져야 한다. <span class="math inline">\(1\)</span> 행부터 <span class="math inline">\(l\)</span> 행까지가 <span class="math inline">\(0\)</span> 행이 아니라고 가정하자.</p>
<p>(<span class="math inline">\(2\)</span>) 우리는 행 기본 연산에 의해 행공간이 바뀌지 않는다는 것을 안다. 따라서 <span class="math inline">\(\boldsymbol{S}\)</span> 와 <span class="math inline">\(\boldsymbol{T}\)</span> 의 행공간이 같아야 한다. <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{m \times n}(\mathbb{F})\)</span> 일 때 <span class="math inline">\(\boldsymbol{S}\)</span> 와 <span class="math inline">\(\boldsymbol{T}\)</span> 의 각 행은 <span class="math inline">\(\mathcal{M}_{1\times n}(\mathbb{F})\)</span> 벡터이다. <span class="math inline">\(s_i,\,i=1,\ldots,l\)</span> 을 행렬 <span class="math inline">\(\boldsymbol{S}\)</span> 의 <span class="math inline">\(i\)</span> 행에서 첫번째 <span class="math inline">\(1\)</span> 이 나오는 열 인덱스 이라 하자. <span class="math inline">\(t_i,\, i=1,\ldots,l\)</span> 도 <span class="math inline">\(\boldsymbol{T}\)</span> 에 대해 마찬가지로 정의하자. <span class="math inline">\(s_1 &gt; t_1\)</span> 이라면 <span class="math inline">\(\boldsymbol{T}_{1:}\)</span> 은 <span class="math inline">\(\boldsymbol{S}\)</span> 의 행공간에 존재하지 않는다. <span class="math inline">\(s_1&lt;t_1\)</span> 이면 <span class="math inline">\(\boldsymbol{S}_{1:}\)</span> 은 <span class="math inline">\(\boldsymbol{T}\)</span> 의 행공간에 존재하지 않는다. 따라서 <span class="math inline">\(s_1=t_1\)</span> 이다. 마찬가지로 <span class="math inline">\(s_2 = t_2, \cdots , s_l = t_l\)</span> 임을 보일 수 있다.</p>
<p>(<span class="math inline">\(3\)</span>) (<span class="math inline">\(2\)</span>) 로부터 <span class="math inline">\(\boldsymbol{S}_{j:} \in \text{span}(\boldsymbol{T}_{j:},\, \boldsymbol{T}_{(j+1):},\ldots, \boldsymbol{T}_{l:})\)</span> 임을 안다. 따라서</p>
<p><span class="math display">\[
\boldsymbol{S}_{1:} =  a_1 \boldsymbol{T}_{1:} + \cdots + a_l \boldsymbol{T}_{l:}
\]</span></p>
<p>인 <span class="math inline">\(a_1,\ldots,\,a_l\)</span> 이 존재한다. 여기서 <span class="math inline">\(s_1=t_1\)</span> 이므로 <span class="math inline">\(a_1=1\)</span> 이다. 또한 <span class="math inline">\(s_2,\ldots,\,s_l\)</span> 번째 성분을 고려하면 <span class="math inline">\(a_2=\cdots =a_l=0\)</span> 임을 안다. 따라서 <span class="math inline">\(\boldsymbol{S}_{1:} = \boldsymbol{T}_{1:}\)</span> 이다. 이렇게</p>
<p><span class="math display">\[
\boldsymbol{S}_{j:} = a_j \boldsymbol{T}_{j:} + a_{j+1}\boldsymbol{T}_{(j+1):} + \cdots + a_l \boldsymbol{T}_{l:}
\]</span></p>
<p>과 <span class="math inline">\(s_j=t_j,\ldots, s_{l}=t_{l}\)</span> 을 생각하면 <span class="math inline">\(\boldsymbol{S}_{j:} =\boldsymbol{T}_{j:}\)</span>, <span class="math inline">\(j=1,\ldots, l\)</span> 이다. 즉 <span class="math inline">\(\boldsymbol{S}=\boldsymbol{T}\)</span> 이므로 행 간소 사다리꼴은 유일하다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
<section id="sec-reduced_row_echelon_form_of_inverse_matrix" class="level3" data-number="3.6.4">
<h3 data-number="3.6.4" class="anchored" data-anchor-id="sec-reduced_row_echelon_form_of_inverse_matrix"><span class="header-section-number">3.6.4</span> 가역행렬의 행 간소 사다리꼴, 역행렬 과 행렬식</h3>
<div id="prp-reduced_echelon_form_of_invertible_matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.24</strong></span> 가역행렬의 행 간소 사다리꼴 형태는 항등행렬이다. 또한 가역행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 가 기본행렬의 곱 <span class="math inline">\(\boldsymbol{E}\)</span> 에 의해 항등행렬 이 되었다고 할때 <span class="math inline">\(\boldsymbol{E}\)</span> 는 <span class="math inline">\(\boldsymbol{A}\)</span> 의 역행렬이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 가 기본행렬의 곱 <span class="math inline">\(\boldsymbol{E}\)</span> 에 의해 행 간소 사다리꼴 <span class="math inline">\(\boldsymbol{A}'\)</span> 으로 변화하였다고 하자. <a href="#prp-rank_of_matrix" class="quarto-xref">명제&nbsp;<span>3.19</span></a> 에 따라 가역행렬이라면 <span class="math inline">\(\text{nullity} (\boldsymbol{A})=0\)</span> 이므로 <span class="math inline">\(\boldsymbol{A}'\)</span> 에 <span class="math inline">\(0\)</span> 으로만 이루어진 행이 없어야 한다. 행 간소 사다리꼴이므로 <span class="math inline">\(i\)</span> 행에서 첫번째 <span class="math inline">\(1\)</span> 의 위치를 <span class="math inline">\(l_i\)</span> 라 하면 <span class="math inline">\(l_i \ge i (i=1,\ldots, n)\)</span> 이다. 또한 <span class="math inline">\(\boldsymbol{A}\)</span> 가 정사각 행렬이며 <span class="math inline">\(0\)</span> 행이 없어야 하므로 <span class="math inline">\(l_n \le n\)</span> 이다. 이 두가지로부터 <span class="math inline">\(l_i = i,\, i = 1,\ldots, n\)</span> 임을 알 수 있으며 이런 행 간소 사다리꼴은 항등행렬 <span class="math inline">\(\boldsymbol{I}_n\)</span> 뿐이다. 즉 <span class="math inline">\(\boldsymbol{EA}=\boldsymbol{I}_n\)</span> 이므로 <span class="math inline">\(\boldsymbol{E}=\boldsymbol{A}^{-1}\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>우리는 앞서 <a href="#prp-zero_determinant_of_linear_dependency" class="quarto-xref">명제&nbsp;<span>3.15</span></a> 에서 행렬의 행벡터들이 선형종속이면, 혹은 열벡터들이 선형 종속이면 행렬식이 0 이 됨을 보였다. 이제 그 역에 대해서도 보일 수 있다.</p>
<div id="prp-determinant_of_invertible_matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.25</strong></span> <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 에 대해 다음은 동치이다.</p>
<ol type="1">
<li><p><span class="math inline">\(\boldsymbol{A}\)</span> 는 가역행렬이다.</p></li>
<li><p><span class="math inline">\(\det (\boldsymbol{A}) \ne 0\)</span>.</p></li>
</ol>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{A}\)</span> 가 기본 행 연산 <span class="math inline">\(\boldsymbol{E}_1,\ldots,\,\boldsymbol{E}_N\)</span> 을 통해 행 간소 사다리꼴 <span class="math inline">\(\boldsymbol{A}'\)</span> 이 되었다고 하자. 즉, <span class="math display">\[
\det (\boldsymbol{A}') = \det (\boldsymbol{E}_N) \cdots \det (\boldsymbol{E}_1) \det (\boldsymbol{A})
\]</span></p>
<p>임을 안다. <a href="#prp-elementary_row_operation_and_determinant" class="quarto-xref">명제&nbsp;<span>3.12</span></a> 을 다시 한번 보자. <span class="math inline">\(\det (\boldsymbol{E}^{(1)}(i, j))=-1\)</span> 이며 <span class="math inline">\(\det (\boldsymbol{E}^{(2)}(j, t))=t\)</span> 이고 <span class="math inline">\(\det (\boldsymbol{E}^{(3)}(i, j, r))=1\)</span> 이므로, 모든 기본 행 연산의 행렬식은 <span class="math inline">\(0\)</span> 이 아니다. 따라서,</p>
<p><span class="math display">\[
\det (\boldsymbol{A}) \ne 0 \iff \det (\boldsymbol{A}') \ne 0
\]</span></p>
<p>이다.</p>
<p><span class="math inline">\(\boldsymbol{A}\)</span> 가 가역행렬인 경우 그 행 간소 사다리꼴이 단위행렬이므로 <span class="math inline">\(\det (\boldsymbol{A}') = 1\)</span> 이며, 따라서 <span class="math inline">\(\det (\boldsymbol{A}') \ne 0\)</span> 이다. <span class="math inline">\(\boldsymbol{A}\)</span> 가 가역행렬이 아니라면 <span class="math inline">\(\boldsymbol{A}'\)</span> 에 <span class="math inline">\(0\)</span> 으로 이루어진 행이 존재하므로 그 행렬식이 <span class="math inline">\(0\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
<section id="sec-triangular_matrix" class="level3" data-number="3.6.5">
<h3 data-number="3.6.5" class="anchored" data-anchor-id="sec-triangular_matrix"><span class="header-section-number">3.6.5</span> 삼각행렬의 성질</h3>
<div id="prp-properties_of_upper_triangular-matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.26</strong></span> 상삼각행렬은 다음과 같은 성질을 가진다.</p>
<p>  (<span class="math inline">\(1\)</span>) 상삼각행렬의 곱은 상삼각행렬인다.</p>
<p>  (<span class="math inline">\(2\)</span>) 상삼각행렬이 가역가역행렬이라는 것과 모든 대각성분이 <span class="math inline">\(0\)</span> 이 아니라는 것은 동치이다.</p>
<p>  (<span class="math inline">\(3\)</span>) 상삼각행렬의 역행렬은 상삼각행렬이다.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(1\)</span>) <a href="#exm-multiplication_of_diagonal_matrix" class="quarto-xref">보기&nbsp;<span>3.6</span></a> 에서 보였다.</p>
<p>(<span class="math inline">\(2\)</span>) <a href="#exm-determinant_of_upper_lower_triangular_matrix" class="quarto-xref">보기&nbsp;<span>3.7</span></a> 에서 보였다.</p>
<p>(<span class="math inline">\(3\)</span>) <span class="math inline">\(\boldsymbol{A} \in \mathcal{M}_{n \times n}(\mathbb{F})\)</span> 가 가역인 상 삼각행렬이라고 하자. 가역이므로 모든 대각성분이 <span class="math inline">\(0\)</span> 이 아니다. 가우스 조단 소거법을 생각하면 피보팅이 필요 없으며, 각 행을 그 행의 대각성분의 역수를 곱해주면 모든 행의 대각성분이 선행 1 성분이 된다. 각 행에 스칼라 곱을 수행하는 행 기본연산은 대각행렬이다. 또한 <span class="math inline">\(n-1\)</span> 행부터 <span class="math inline">\(E^{(3)}(i, j, r)\)</span> 연산을 통해 대각성분이 아닌 성분을 모두 없엘 수있다. 이 때 <span class="math inline">\(i&lt;j\)</span> 이므로 <span class="math inline">\(E^{(3)}\)</span> 연산에 대한 행렬은 상삼각행렬이다. 행 기본연산 <span class="math inline">\(\boldsymbol{E}_1,\ldots,\,\boldsymbol{E}_N\)</span> 을 통해 <span class="math inline">\(\boldsymbol{A}\)</span> 가 항등행렬 <span class="math inline">\(\boldsymbol{I}_n\)</span> 이 되었다고 하자. 즉,</p>
<p><span class="math display">\[
\boldsymbol{E}_N \cdots \boldsymbol{E}_1\boldsymbol{A} =\boldsymbol{I}_n
\]</span></p>
<p>이라고 했을 때 각각의 <span class="math inline">\(\boldsymbol{E}_j\)</span> 는 대각행렬이거나 상삼각 행렬이므로 <span class="math inline">\(\boldsymbol{E}=\boldsymbol{E}_N \cdots \boldsymbol{E}_1\)</span> 은 상삼각행렬이다. 그런데 <span class="math inline">\(\boldsymbol{E}=\boldsymbol{A}^{-1}\)</span> 이므로 상삼각행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 역행렬은 상삼각행렬이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>상삼각행렬의 전치행렬이 하삼각행렬이므로 하삼각행렬에 대해서도 다음을 알 수 있다.</p>
<div id="prp-properties_of_lower_triangular-matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3.27</strong></span> 하삼각행렬은 다음과 같은 성질을 가진다.</p>
<p>  (<span class="math inline">\(1\)</span>) 하삼각행렬의 곱은 하삼각행렬인다.</p>
<p>  (<span class="math inline">\(2\)</span>) 하삼각행렬이 가역가역행렬이라는 것과 모든 대각성분이 <span class="math inline">\(0\)</span> 이 아니라는 것은 동치이다.</p>
<p>  (<span class="math inline">\(3\)</span>) 하삼각행렬의 역행렬은 하삼각행렬이다.</p>
</div>
<p><br></p>
</section>
</section>
<section id="연습문제" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="연습문제"><span class="header-section-number">3.7</span> 연습문제</h2>
<div id="exr-determinant_with_standard_vector" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 3.4</strong></span> <span class="math inline">\(\boldsymbol{A}\in \mathcal{M}_{n\times n}(\mathbb{F})\)</span> 의 첫번째 행이 <span class="math inline">\(c\boldsymbol{e}_1\)</span>, 즉 첫번째 열이 <span class="math inline">\(c\)</span> 이며 나머지 열은 <span class="math inline">\(0\)</span> 이라면 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행렬식은 <span class="math inline">\(\boldsymbol{A}\)</span> 에서 <span class="math inline">\(1\)</span> 행과 <span class="math inline">\(1\)</span> 열을 제외한 <span class="math inline">\((n-1)\times (n-1)\)</span> 행렬의 행렬식과 같다는 것을 보여라.</p>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span>행렬식의 정의를 보자.</p>
<p><span class="math display">\[
\begin{aligned}
\det(\boldsymbol{A}) &amp;= \sum_{\sigma\in S_n} \text{sgn}(\sigma) \prod_{i=1}^n A_{i,\, \sigma (i)}
\end{aligned}
\]</span></p>
<p>여기서 <span class="math inline">\(A_{1,\sigma(i)}\)</span> 는 <span class="math inline">\(A_{11}\)</span> 을 제외하면 모두 <span class="math inline">\(0\)</span> 이므로,</p>
<p><span class="math display">\[
\begin{aligned}
\det(\boldsymbol{A}) &amp;= c\sum_{\sigma\in S_n} \text{sgn}(\sigma) \prod_{i=2}^n A_{i,\, \sigma (i)} \\
\end{aligned}
\]</span></p>
<p>이다. 임의의 <span class="math inline">\(\sigma\in S_n\)</span> 에서 <span class="math inline">\(\sigma(1) = 1\)</span> 로 고정시켰을 만을 생각하자. 그렇다면 <span class="math inline">\(\sigma\)</span> 는 <span class="math inline">\(2\)</span> 에서 <span class="math inline">\(n\)</span> 까지의 자연수에 대한 순환과 같으므로 <span class="math inline">\(\boldsymbol{A}\)</span> 에서 <span class="math inline">\(1\)</span> 행과 <span class="math inline">\(1\)</span> 열을 제외한 부분행렬을 <span class="math inline">\(\boldsymbol{A}_1\)</span> 이라고 하면 <span class="math inline">\(\det (\boldsymbol{A}) = c\det(\boldsymbol{A}_1)\)</span> 이다.</p>
</div>
<p><br></p>
<div id="exr-determinant_of_vandermond_matrix" class="theorem exercise">
<p><span class="theorem-title"><strong>연습문제 3.5 (Vandermond 행렬의 행렬식)</strong></span> <span class="math inline">\(t_0,\,\ldots,\,t_n \in \mathbb{F}\)</span> 에 대해 아래와 같이 정의된 행렬을 Vandermond 행렬 이라고 한다.</p>
<p><span id="eq-vandermond_matrix"><span class="math display">\[
\boldsymbol{V} = \begin{bmatrix} 1 &amp; t_0 &amp; t_0^2 &amp; \cdots &amp; t_0^n \\ 1 &amp; t_1 &amp; t_1^2 &amp; \cdots &amp; t_1^n \\ &amp; &amp; \vdots &amp; &amp; \\ 1 &amp; t_n^1 &amp; t_n^2 &amp; \cdots &amp; t_n^n\end{bmatrix}.
\tag{3.1}\]</span></span></p>
<p>이 때 행렬식이 다음과 같음을 보여라.</p>
<p><span id="eq-determinant_of_vandermond_matrix"><span class="math display">\[
\det(V) = \prod_{0 \le i &lt; j \le n} (t_j-t_i)
\tag{3.2}\]</span></span></p>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>(해답)</em>. </span>행렬식의 정의를 보면 행렬식은 각 열에서 행-인덱스가 겹치지 않게 고른 것들을 <span class="math inline">\(1\)</span> 혹은 <span class="math inline">\(-1\)</span> 을 곱해 합한것이라는 것을 알 수 있다. 각 <span class="math inline">\(j\)</span> 열은 <span class="math inline">\(t_i\)</span> 에 대한 <span class="math inline">\(j-1\)</span> 차 항이므로 <span class="math inline">\(\det(\boldsymbol{V})\)</span> 는 <span class="math inline">\(t_0^{p_0}t_1^{p_1}\cdots t_n^{p_n}\)</span> 의 선형합이며 <span class="math inline">\(p_0+\cdots + p_n = \dfrac{n(n+1)}{2}\)</span> 임을 알 수 있다.</p>
<p>또한 <span class="math inline">\(1\le i,\,j \le n\)</span> 가운데 둘중 하나만이라도 같으면 행렬식은 <span class="math inline">\(0\)</span> 이 된다.</p>
<p><span class="math display">\[
q(t_0,\ldots,\,t_n) := \prod_{0\le i&lt;j\le n} (t_j -t_i)
\]</span></p>
<p>라고 정의하면 <span class="math inline">\(q(t_0,\ldots,\,t_n)\)</span> 은 <span class="math inline">\(\det(\boldsymbol{V})\)</span> 를 나눈다. 그런데 <span class="math inline">\(q(t_0,\ldots,\,t_n)\)</span> 역시 <span class="math inline">\(t_0^{p_0}t_1^{p_1}\cdots t_n^{p_n}\)</span> 의 선형합이며 <span class="math inline">\(p_0+\cdots + p_n = \dfrac{n(n+1)}{2}\)</span> 이다. 즉 <span class="math inline">\(\det(\boldsymbol{V})\)</span> 는 <span class="math inline">\(q(t_0,\ldots,\,t_n)\)</span> 의 상수배이다. 그렇다면</p>
<p><span class="math display">\[
\det(\boldsymbol{V}) = c\cdot q(t_1,\ldots,\,t_n) = c\prod_{0\le i&lt;j\le n} (t_j- t_i)
\]</span></p>
<p>여기서 <span class="math inline">\(\boldsymbol{V}\)</span> 의 대각성분의 곱을 보자. 대각성분의 순열은 항등순열이므로 <span class="math inline">\(\text{sgn}\)</span> 값은 <span class="math inline">\(1\)</span> 이다. 즉, <span class="math inline">\(\det(\boldsymbol{V})\)</span> 에서 <span class="math inline">\(t_1 t_2^2 \cdots t_n^n\)</span> 의 계수는 <span class="math inline">\(1\)</span> 이다. 그리고 <span class="math inline">\(\cdot \prod_{1 \le i &lt; j \le n}(t_j-t_i)\)</span> 에서 <span class="math inline">\((t_j-t_i)\)</span> 중 앞에 있는 것들의 곱을 모으면 <span class="math inline">\(t_1 t_2^2 \cdots t_n^n\)</span> 이다. 즉 <span class="math inline">\(c=1\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../src/part1/ch1_02_linear_map.html" class="pagination-link" aria-label="선형사상">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">선형사상</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../src/part1/ch1_06_eigenvalue.html" class="pagination-link" aria-label="고유값과 고유벡터">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">고유값과 고유벡터</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>